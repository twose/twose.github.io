<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TWO SEE</title>
  
  <subtitle>SEE is the sea of cc</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.twosee.cn/"/>
  <updated>2021-12-04T15:15:47.062Z</updated>
  <id>http://www.twosee.cn/</id>
  
  <author>
    <name>Twosee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在MacOS平台上进行C开发的一些经验（Apple M1）</title>
    <link href="http://www.twosee.cn/2021/12/04/develop-on-apple/"/>
    <id>http://www.twosee.cn/2021/12/04/develop-on-apple/</id>
    <published>2021-12-04T13:50:12.000Z</published>
    <updated>2021-12-04T15:15:47.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近把从2017年就开始用的13寸乞丐版MacBookPro淘汰了。它是我打从学习编程开始就一直在用的电脑，到现在也有四年了，多少有点感情，但它实在是太卡了，因此，我不得不……<a id="more"></a></p><p>因为太卡了，放弃了eclipse转用vscode，但vscode的宏展开始终没有eclipse好用，不能无限层级往下展开，而是只能展开一层，对于看PHP内核或者PHP扩展这种宏孩儿少不了的代码来说不是很友好。 </p><p>因为太卡了，PhpStorm还得定期重启，键入代码有延迟，在PHP内核里checkout一个branch要花费甚至几分钟的时间，所以贡献也变少了… 有些patch写了以后也没提交。</p><p>因为太卡了，编译一次PHP可能得十来分钟，编译一次Swoole扩展得两三分钟，编译Swow和libcat稍微好一点，都是纯C项目，但如果是完全从头编译，也是分钟级的。</p><p>尤其是在虚拟机中编译，大概是文件系统慢的问题，make clean都要跑好一会，编译速度慢的那叫离谱他妈给离谱开门，离谱到家了。</p><p>那么为什么使用虚拟机呢？因为MacOS下无法使用valgrind，不能进行内存问题跟踪，没有strace，不能进行系统调用跟踪。</p><p>lldb倒是挺好用的，除了不支持source gdb脚本以外，几乎没有缺点，watchpoint功能也比gdb好用。</p><p>但是综上，很多时候问题都只能在Linux下调试，所以不得不上虚拟机。</p><h2 id="一波三折"><a href="#一波三折" class="headerlink" title="一波三折"></a>一波三折</h2><p>MacBook Pro 2021新款 带着 M1 Pro / Max横空出世，发布会当天因为一些事情累得不行，睡得很早，但是发布会开始的那个点，突然就从梦中惊醒，从床上垂死病中惊坐起，看完了发布会，感觉这新电脑真的是非常的amazing啊。而且我从19年开始一直在做等等党，本着永不言败的心态，结果输得彻彻底底，这次是非买不可了，第二天开始就一直蹲着等下单，然后第一时间购入了顶配，四年前是家里人赞助我买的，所以选择了最低配，但如今它已是我吃饭的家伙，性能就是生产力，这一次，顶配必须拿捏！</p><p>没想到，接下来竟是一个多月的苦等，64G全面缺货，大批订单延期，知乎上甚至还有一帮知友组了个维权群，加进去一看，受害者竟高达上百人……</p><p>期间公司还组织了团购，说是可能有85折优惠，听得我差点送去吸氧气瓶。</p><h2 id="以下是正文-或许"><a href="#以下是正文-或许" class="headerlink" title="以下是正文 (或许)"></a>以下是正文 (或许)</h2><p>一波三折还是到手了。</p><h2 id="纯净迁移"><a href="#纯净迁移" class="headerlink" title="纯净迁移"></a>纯净迁移</h2><p>首先，由于是intel转m1，x86转arm，所以用时间机器去转移老电脑的数据并不是一个明智的选择，而且原来的电脑积攒了四年的垃圾文件，有些初学时就深埋在我系统目录里的各种垃圾文件和奇怪配置也不好处理，所以我选择了重新捣鼓系统。</p><p>迁移比预想的要顺利很多，连起来算不到一天我就把所有东西都迁移完了，老电脑上看似不可或缺的东西很多，但其实常用的就那么一些。</p><p>顺便，有很多网站可以看M1上现在有哪些软件可用，哪些不可用，这里推荐一个：<a href="https://doesitarm.com/" target="_blank" rel="noopener">https://doesitarm.com/</a></p><p>目前我用到的除了luajit，没有不能用的，噢还有个pcre.jit，记得在编译PHP的时候用<code>--without-pcre-jit</code>选项关闭噢，不然会报warning，PHP内核本身的 <code>make install</code>里使用了PHP脚本，如果不关闭，安装都安装不了。</p><h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>homebrew在m1上的默认包安装路径从<code>/usr/local</code>变成了<code>/opt/homebrew</code>, blame了官方提交也没说是为什么，但README里说不按默认路径来可能会遇到奇怪的问题，所以还是老老实实转用<code>/opt/homebrew/</code>吧。</p><p>然后环境变量里需要配好多环境变量，那些C项目才能build起来，这里稍微分享下我当前的环境变量配置（放在<code>zshrc</code>里的）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">export PATH=<span class="string">"\</span></span><br><span class="line"><span class="string">$(brew --prefix openssl@1.1)/bin:\</span></span><br><span class="line"><span class="string">$(brew --prefix libiconv)/bin:\</span></span><br><span class="line"><span class="string">$(brew --prefix curl)/bin:\</span></span><br><span class="line"><span class="string">$(brew --prefix bison)/bin:\</span></span><br><span class="line"><span class="string">$PATH\</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line">export LDFLAGS=<span class="string">"$LDFLAGS \</span></span><br><span class="line"><span class="string">-L$(brew --prefix openssl@1.1)/lib \</span></span><br><span class="line"><span class="string">-L$(brew --prefix libiconv)/lib \</span></span><br><span class="line"><span class="string">-L$(brew --prefix curl)/lib \</span></span><br><span class="line"><span class="string">-L$(brew --prefix bison)/lib \</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">export LIBS=<span class="string">"$LIBS -lssl -lcrypto"</span></span><br><span class="line"></span><br><span class="line">export CFLAGS=<span class="string">"$CFLAGS \</span></span><br><span class="line"><span class="string">-I$(brew --prefix openssl@1.1)/include \</span></span><br><span class="line"><span class="string">-I$(brew --prefix libiconv)/include \</span></span><br><span class="line"><span class="string">-I$(brew --prefix curl)/include \</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">export CPPFLAGS=<span class="string">"$CPPFLAGS \</span></span><br><span class="line"><span class="string">-I$(brew --prefix openssl@1.1)/include \</span></span><br><span class="line"><span class="string">-I$(brew --prefix libiconv)/include \</span></span><br><span class="line"><span class="string">-I$(brew --prefix curl)/include \</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">export PKG_CONFIG_PATH=<span class="string">"\</span></span><br><span class="line"><span class="string">$(brew --prefix openssl@1.1)/lib/pkgconfig:\</span></span><br><span class="line"><span class="string">$(brew --prefix curl)/lib/pkgconfig:\</span></span><br><span class="line"><span class="string">$PKG_COFNIG_PATH\</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">export OPENSSL_ROOT_DIR=<span class="string">"$(brew --prefix openssl@1.1)"</span></span><br><span class="line">export OPENSSL_LIBS=<span class="string">"-L$(brew --prefix openssl@1.1)/lib"</span></span><br><span class="line">export OPENSSL_CFLAGS=<span class="string">"-I$(brew --prefix openssl@1.1)/include"</span></span><br></pre></td></tr></table></figure><p>我对于C构建系统也就是懂点皮毛，能写CMakeList和autoconf生态的m4，90%的构建问题都能自行解决但有时候也不知道原理是啥的那种程度，就我在m1构建C项目的体验上而言，我觉得对于完全不懂构建系统的小伙伴来说，想编译明白东西还是会挺痛苦的。</p><h2 id="All-in-MacOS-之-为啥不需要虚拟机了"><a href="#All-in-MacOS-之-为啥不需要虚拟机了" class="headerlink" title="All in MacOS 之 为啥不需要虚拟机了"></a>All in MacOS 之 为啥不需要虚拟机了</h2><p>我现在基本上all in macOS了，macOS成为了我的主力开发环境，没有虚拟机套娃肯定是性能最优的，但是调试的问题怎么解决呢。</p><h3 id="内存跟踪问题"><a href="#内存跟踪问题" class="headerlink" title="内存跟踪问题"></a>内存跟踪问题</h3><p>首先，我给PHP内核、Swow、libcat都加了ASan编译选项的支持，而且这玩意就算没有项目的编译选项支持，手动加个gcc编译参数也能搞定，ASan是个好东西，我觉得所有C/C++开发都需要深入了解下，包括它的原理。比较浅显的好处就是，ASan可以在几乎任何环境里跑，完美解决了macOS下对于内存问题跟踪的需求。</p><p>而且valgrind的性能比较捉急，有时候就难堪大用，它会使程序性能下降十倍以上，而有些对于时间、并发敏感的BUG，在valgrind下就复现不出来了，常常跟踪了个寂寞。而ASan在编译期就用了影子内存和hook一些内存函数的技巧，性能碾压valgrind。</p><h3 id="系统调用跟踪问题"><a href="#系统调用跟踪问题" class="headerlink" title="系统调用跟踪问题"></a>系统调用跟踪问题</h3><p>Intel的Mac开机时候按住command + R，而arm的Mac只需要开机时一直按住开机键，就能进到恢复模式。</p><p>进去以后菜单栏里打开终端，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ csrutil disable</span><br><span class="line">$ csrutil enable --without debug --without dtrace</span><br></pre></td></tr></table></figure><p>先关掉SIP再打开，但是排除掉我们需要的部分。</p><p>需要注意的是有些系统版本好像是<code>--without dtruss</code>，但是m1上只有dtrace好使，但我们实际用的又是<code>dtruss</code>，非常莫名其妙。</p><p>可以用<code>csrutil status</code>查看结果，平时不在恢复模式也可以看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ csrutil status</span><br><span class="line">System Integrity Protection status: unknown (Custom Configuration).</span><br><span class="line"></span><br><span class="line">Configuration:</span><br><span class="line">Apple Internal: disabled</span><br><span class="line">Kext Signing: enabled</span><br><span class="line">Filesystem Protections: enabled</span><br><span class="line">Debugging Restrictions: disabled</span><br><span class="line">DTrace Restrictions: disabled</span><br><span class="line">NVRAM Protections: enabled</span><br><span class="line">BaseSystem Verification: enabled</span><br><span class="line">Boot-arg Restrictions: enabled</span><br><span class="line">Kernel Integrity Protections: disabled</span><br><span class="line">Authenticated Root Requirement: enabled</span><br><span class="line"></span><br><span class="line">This is an unsupported configuration, likely to break in the future and leave your machine in an unknown state.</span><br></pre></td></tr></table></figure><p>虽然系统说好像自定义设置是unknown state，不过目前用下来没遇到啥问题。</p><p>毕竟都是个开发，有问题再想办法解决嘛。</p><p>然后我们就可以用<code>dtruss</code>来代替<code>strace</code>了。</p><p>此外，由于libcat是基于libuv的协程版libuv，所以不需要自己操心跨平台的问题，理论上一个系统下开发完了，各个系统都能跑。</p><p>当然，实际情况并不是100%这么理想的，还是会有那么一点边缘问题，但是我们有一大堆各种系统的CI去保证跨平台兼容性，甚至有什么龙芯、鲲鹏的机器（都是@dixyes搞的，我也不甚懂），似乎我们已经实现了好多个「第一个运行在XX平台的PHP协程库/框架」的成就，总之就是非常的牛啤。</p><h2 id="编译性能"><a href="#编译性能" class="headerlink" title="编译性能"></a>编译性能</h2><p>我习惯在编译的时候用<code>make &gt; /dev/null</code>，把标准输出重定向吃掉，这样就可以只看warning了，比较清爽。</p><p>然后，在新电脑上第一次编译的时候，我靠，就顿了一小会，就结束退出了，我还以为坏了，遇到M1上的BUG了，编译都闪退了……</p><p>结果是编译太快了，原来我要几分钟的编译，不到五秒秒就完成了……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ time make -j8 &gt;&#x2F;dev&#x2F;null</span><br><span class="line">make -j8 &gt; &#x2F;dev&#x2F;null  11.13s user 15.77s system 614% cpu 4.375 total</span><br></pre></td></tr></table></figure><p>原来编译的时间太长，电脑还卡的啥也干不了，风扇锁7200转声音巨大无比，所以一般编译一下就看会手机，精力很分散。</p><p>而现在，几乎是所见即所得，哪怕是从头开始编译，也只需要几秒钟，编程体验极大提升。</p><p>而且所有IDE现在都是丝滑流畅，写起代码来不要太爽，感觉被封印了很久的写代码的激情又回来了。</p><h2 id="Windows虚拟机下的游戏性能"><a href="#Windows虚拟机下的游戏性能" class="headerlink" title="Windows虚拟机下的游戏性能"></a>Windows虚拟机下的游戏性能</h2><p>其实有自己的Windows电脑，肯定是不会在这台Mac上玩的，但是出于好奇和执念，还是试了试。</p><p>执念是因为毕业前回学校那段时间，只带了Mac本回去，几个月没打游戏，有点难受，就搞了个虚拟机玩了一会命运石之门，结果这都卡的不行，就很气人。</p><p>而新Mac还有120hz高刷屏，听说显卡性能也还不错，似乎可以一战。但是又由于架构问题，加上虚拟机，可能就好几层套娃，那个性能可能也是没眼看。</p><p>最终尝试的结果是，命运石之门这种文字冒险游戏肯定是丝滑流畅。斗胆试了下CSGO，1080p 200帧无压力，也是非常的amazing，但是实际匹配的时候会出现顿卡，但也没有很影响游戏体验，就是会突然从120掉到40帧那么零点几秒，感觉可能和虚拟机或者转译有关？但是正经人谁会在Mac上打CSGO呢…… 玩了一把以后卸载了，毕竟我这个Windows虚拟机可能未来还是要作为Win下构建调试项目的用途。</p><h2 id="其实写这篇文章就是体验一下新电脑的丝滑的，没有什么别的意思，内容也比较水，纯当练练打字，有好多M1上的经验点一时半会也想不起来了，后面想到了再补吧。"><a href="#其实写这篇文章就是体验一下新电脑的丝滑的，没有什么别的意思，内容也比较水，纯当练练打字，有好多M1上的经验点一时半会也想不起来了，后面想到了再补吧。" class="headerlink" title="其实写这篇文章就是体验一下新电脑的丝滑的，没有什么别的意思，内容也比较水，纯当练练打字，有好多M1上的经验点一时半会也想不起来了，后面想到了再补吧。"></a>其实写这篇文章就是体验一下新电脑的丝滑的，没有什么别的意思，内容也比较水，纯当练练打字，有好多M1上的经验点一时半会也想不起来了，后面想到了再补吧。</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近把从2017年就开始用的13寸乞丐版MacBookPro淘汰了。它是我打从学习编程开始就一直在用的电脑，到现在也有四年了，多少有点感情，但它实在是太卡了，因此，我不得不……
    
    </summary>
    
    
      <category term="PHP" scheme="http://www.twosee.cn/tags/PHP/"/>
    
      <category term="macOS" scheme="http://www.twosee.cn/tags/macOS/"/>
    
      <category term="m1" scheme="http://www.twosee.cn/tags/m1/"/>
    
      <category term="C" scheme="http://www.twosee.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>多路复用一样会阻塞用户线程，那它和同步阻塞有什么区别？</title>
    <link href="http://www.twosee.cn/2021/07/20/zhihu-sea-king/"/>
    <id>http://www.twosee.cn/2021/07/20/zhihu-sea-king/</id>
    <published>2021-07-20T08:52:37.000Z</published>
    <updated>2021-07-20T08:54:42.201Z</updated>
    
    <content type="html"><![CDATA[<p>知乎问题：<a href="https://www.zhihu.com/question/456131257/answer/1985606916" target="_blank" rel="noopener">多路复用一样会阻塞用户线程，那它和同步阻塞有什么区别? - Twosee的回答</a>：</p><p>有个叫<a href="https://www.zhihu.com/people/a01b31c1866925866da206222911c20c" target="_blank" rel="noopener">@轩辕之风</a>的答主用打电话和微信作比喻，让我觉得很有意思，所以作了这篇回答。</p><p>同步阻塞就是语音通话，一个人<strong>同时只能处理一个会话</strong>，对端不说话就是<strong>读阻塞</strong>，你说的太快对方听不过来就是<strong>写阻塞</strong>… 但是用短信作为多路复用的比喻让我感觉差了那么点意思，或许改成QQ微信聊天更佳，我斗胆扩写一下：</p><a id="more"></a><p>普通人：</p><ul><li>在和女神的单聊界面苦等（<strong>阻塞等待</strong>，对应阻塞的recv()等）</li><li>工作的时候也要动不动关注女神有没有回复，陷入备胎陷阱，心思没办法维持在工作上，效率低下 （CPU时间被大量浪费在阻塞系统调用上，<strong>频繁陷入内核态</strong>，上下文切换开销很大）</li><li>出现了新的恋爱机会，但是没办法同时处理，因此只能拱手让人（<strong>一个同步阻塞进程同时只能处理一个连接</strong>，当Master进程调度时或当其他进程也在监听同一端口时(REUSE_PORT)，新的连接会被分配给其它进程）</li><li>虽然看起来很捞，但是很专一 ，并且这也是大多数普通人的求偶方式。（虽然性能不如多路复用，但是网络编程生态很大一部分都建立在同步阻塞的编程模型之上，并且它易于理解，对于开发者<strong>心智负担较低</strong>）</li></ul><p>海王：</p><ul><li>从不在工作的时候主动等消息，游刃有余（充分利用CPU时间，<strong>尽量跑在用户态</strong>上）</li><li>有空摸鱼的时候才顺便打理鱼塘，看下手机有没有消息（CPU运算任务告一段落，检查是否有IO事件，对应<strong>epoll_wait()</strong>之类的调用）</li><li>检查有多少个妹子给自己发消息了，点亮手机发现收到100个联系人的未读消息通知 （epoll_wait()返回了100，说明有100个<strong>文件描述符就绪</strong>）</li><li>遍历处理，但绝不在和某个妹子的会话上单独等待，除非除了把妹之外没事可干了，否则处理完后马上就该干嘛干嘛，进入下一轮循环。（遍历处理<strong>可读可写事件</strong>，执行<strong>非阻塞</strong>IO操作，即不会长时间阻塞在某个socket上，而是进入下一轮事件循环再<strong>统一等待</strong>）</li></ul><p>那么，哪怕是一个只会把妹，别的人事啥也不干的海王，它搞定100个妹子的时间也不过是<code>MAX(搞定妹子0的时间, 搞定妹子1的时间, 搞定妹子2的时间, ...搞定妹子99的时间)</code>，而普通人可能就需要 <code>搞定妹子0的时间 + 搞定妹子1的时间 + 搞定妹子2的时间 + 搞定妹子99的时间</code> ，当妹子的数量越多，搞定妹子的时间越长，海王的优势就越明显。（如本地网络IO速度极快，多路复用的性能优势就不明显，而外部网络尤其是<strong>慢速网络环境下，多路复用技术就能体现出其巨大的性能优势</strong>）</p><p>设计合理的高性能海王能快速祸害成百上千的妹子，而同步阻塞的普通人或许终其一生都无法达到十之一二就因为阳寿耗尽（<strong>ETIMEDOUT</strong>）被KILL了。</p><p>原有的车马很慢书信很远一生只够爱一个人已不能满足当代人日渐空虚的内心和永远填不满的情感需求，海王之风因而大行其道（当原有的多进程多线程+同步阻塞模式不能满足<strong>日益增长的高并发需求</strong>，多路复用技术因此而兴起）。</p><hr><p>脑洞又开了开，每当出现一个新来的妹子时，伺机而动的单身狗们全都被惊动，变成舔狗，但它们之中只有一个人能得逞，这就是<strong>惊群</strong>，频繁的惊群极大地损害了得不到妹子的舔狗们的身心，造成了感情的浪费。（惊群问题是计算机科学中，当许多进程等待一个事件，事件发生后这些进程被唤醒，但<strong>只有一个进程能获得执行权</strong>，其他进程又得被阻塞，这造成了<strong>大量的系统上下文切换开销</strong>）</p><p>而如果你是屌丝，你大概率会倒在这几步</p><ul><li>找不到妹子 （DNS resolution failed）</li><li>找到心仪的妹子加微信被拒绝（Connection refused）</li><li>加上妹子了妹子发现你是屌丝然后装死 （Connection timed out）</li><li>加上妹子了妹子发现你是屌丝然后把你删了（Connection reset by peer）</li><li>在你发消息的时候你发现妹子把你删了（Broken pipe）</li><li>妹子把你拉黑了（加入防火墙黑名单）</li></ul><p>但是我们不用气馁，海王撩妹也是有上限的，因为微信有5000个好友的上限，那么即便是最顶级的海王，也只能同时搞定5000个妹子，这就是经典的<strong>C5K问题</strong>(笑，这里对应了<strong>单机能力是有上限的，不能无限扩展</strong>。</p><p>但是坏了，写到这里我才想来，海王可以有多个手机，多个微信，这就升级到<strong>集群</strong>了……集群还可以解决单个微信每天加的妹子太多，被微信限制的问题，多个微信<strong>均衡负载</strong>，每天可以加的妹子数量又上升了…</p><p>高级别的海王意识到用一个微信很容易出岔子，发个朋友圈还得小心翼翼地设置有谁可见，那么它就会对自己的<strong>服务</strong>作<strong>拆分</strong>，工作、家庭、亲戚、朋友、鱼塘全都<strong>解耦</strong>，于是<strong>分布式</strong>海王诞生了…</p><p>注重安全的海王会和妹子用多种社交APP建立联系，防止某个约妹APP突然挂了或是被下架导致鱼塘损失，这是<strong>多活容灾</strong>。</p><p>找到规律的海王会形成一套把妹话术，妹子多了很难一一应付，就在把妹之前<strong>预加载</strong>好话术，根据妹子的类型找到话术<strong>缓存</strong>，降低压力。</p><p>知进退的高级海王知道有些妹子不好对付，引入了<strong>熔断降级</strong>机制，而普通人只知道在一棵树上吊死，感情失败黑化了，想学习海王，结果被妹子拒得心态血<strong>(雪)崩</strong>。</p><p>虽然跑题跑远了… 但是这还可以告诉大家，网络编程到多路复用这里只是刚刚开始，C10K后面还有C10M，现在还喜欢动不动就百万千万亿万并发的，瞎几把编到这里我也编不下去了….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知乎问题：&lt;a href=&quot;https://www.zhihu.com/question/456131257/answer/1985606916&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多路复用一样会阻塞用户线程，那它和同步阻塞有什么区别? - Twosee的回答&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;有个叫&lt;a href=&quot;https://www.zhihu.com/people/a01b31c1866925866da206222911c20c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@轩辕之风&lt;/a&gt;的答主用打电话和微信作比喻，让我觉得很有意思，所以作了这篇回答。&lt;/p&gt;
&lt;p&gt;同步阻塞就是语音通话，一个人&lt;strong&gt;同时只能处理一个会话&lt;/strong&gt;，对端不说话就是&lt;strong&gt;读阻塞&lt;/strong&gt;，你说的太快对方听不过来就是&lt;strong&gt;写阻塞&lt;/strong&gt;… 但是用短信作为多路复用的比喻让我感觉差了那么点意思，或许改成QQ微信聊天更佳，我斗胆扩写一下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>有人发现PHP-7.3后内存占用变大了吗</title>
    <link href="http://www.twosee.cn/2021/05/17/zend-hash-load-factor/"/>
    <id>http://www.twosee.cn/2021/05/17/zend-hash-load-factor/</id>
    <published>2021-05-17T10:11:44.000Z</published>
    <updated>2021-12-04T14:04:12.677Z</updated>
    
    <content type="html"><![CDATA[<p>分享会上讲到了PHP的packed array 与 hash array 对比</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$array = [];</span><br><span class="line">$mem = memory_get_usage();</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">10000</span>; $i++) &#123;</span><br><span class="line">    $array[$i] = $i;</span><br><span class="line">&#125;</span><br><span class="line">var_dump(<span class="string">'mem+='</span> . ($packed_arr_size = (memory_get_usage() - $mem)));</span><br><span class="line"></span><br><span class="line">$array = [];</span><br><span class="line">$mem = memory_get_usage();</span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">10000</span>; $i &gt;= <span class="number">0</span>; $i--) &#123;</span><br><span class="line">    $array[$i] = $i;</span><br><span class="line">&#125;</span><br><span class="line">var_dump(<span class="string">'mem+='</span> . ($hash_arr_size = (memory_get_usage() - $mem)));</span><br><span class="line"></span><br><span class="line">var_dump((($hash_arr_size - $packed_arr_size) / <span class="number">1024</span>) . <span class="string">'K'</span>);</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string(11) &quot;mem+&#x3D;528480&quot;</span><br><span class="line">string(11) &quot;mem+&#x3D;659552&quot;</span><br><span class="line">string(4) &quot;128K&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ae03.alicdn.com/kf/H8a1991c6f3044993ab066ef38ae4992b1.png" alt="哈希表.jpeg" title="">                </div>                <div class="image-caption">哈希表.jpeg</div>            </figure><p>如图，根据理论，压缩数组和哈希数组应该只相差一个索引列表，索引列表每个元素都是uint32, 也就是4个字节, 10000个元素, 桶的个数是2的14次方也就是16384个桶, 那么多占用的就是<code>((4 *16384) / 1024) = 64K</code> ，但实际结果是128k，在课上这里的计算翻车了，算出来是错的。<br>这确实有点神奇，课后源码分析了一波，发现了原因，可以说是非常的amazing……<br>内核书的版本是PHP7.2，但在PHP7.3的时候，PHP内核的核心作者Dmitry在一个小小的提交中把HashTable的负载因子从1改成了0.5 (<a href="https://github.com/php/php-src/commit/34ed8e53fea63903f85326ea1d5bd91ece86b7ae)。" target="_blank" rel="noopener">https://github.com/php/php-src/commit/34ed8e53fea63903f85326ea1d5bd91ece86b7ae)。</a></p><p>什么是负载因子呢，我们课上说了哈希冲突这个内容，显然，索引列表越大，哈希冲突率就越小，查找的速度相应就变快，但是与此同时占用的内存也会变多，在Java中，HashTable默认的负载因子是0.75，在时间和空间成本之间提供了很好的权衡。</p><p>PHP在7.3突然改成0.5，那么索引数组的体积就变为原先的两倍，也就是128k了，我倾向于PHP在时间和空间中再次选择了时间，因此我们可以在PHP7.2升级到PHP7.3后看到可观的性能提升，但也可能会发现应用的内存占用变大了一些…</p><hr><p>后续补充（2021-12-04）：这里当时没有仔细想，由于Bucket结构已经很大了，所以尽管索引结构内存占用变大了，但在从整个HashTable视角来看，内存占用增加的比例其实不大。</p><p>简单计算<code>sizeof(Bucket) + sizeof(uint32_t) = 4byte * 9</code>，现在我们多了<code>sizeof(uint32_t) = 4</code>, 所以每个HashTable的内存占用仅增加了10%。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享会上讲到了PHP的packed array 与 hash array 对比&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$array = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$mem = memory_get_usage();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ($i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; $i &amp;lt; &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;; $i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $array[$i] = $i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var_dump(&lt;span class=&quot;string&quot;&gt;&#39;mem+=&#39;&lt;/span&gt; . ($packed_arr_size = (memory_get_usage() - $mem)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$array = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$mem = memory_get_usage();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ($i = &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;; $i &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; $i--) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $array[$i] = $i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var_dump(&lt;span class=&quot;string&quot;&gt;&#39;mem+=&#39;&lt;/span&gt; . ($hash_arr_size = (memory_get_usage() - $mem)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var_dump((($hash_arr_size - $packed_arr_size) / &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;) . &lt;span class=&quot;string&quot;&gt;&#39;K&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;string(11) &amp;quot;mem+&amp;#x3D;528480&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string(11) &amp;quot;mem+&amp;#x3D;659552&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string(4) &amp;quot;128K&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="zend" scheme="http://www.twosee.cn/tags/zend/"/>
    
  </entry>
  
  <entry>
    <title>漫谈PHP8新特性：命名参数</title>
    <link href="http://www.twosee.cn/2020/07/17/php8-rfc-named-params/"/>
    <id>http://www.twosee.cn/2020/07/17/php8-rfc-named-params/</id>
    <published>2020-07-17T10:25:20.000Z</published>
    <updated>2020-08-04T05:53:32.553Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对「<a href="https://wiki.php.net/rfc/named_params" target="_blank" rel="noopener">命名参数RFC</a>」的个人解读，先让我们来简单看下RFC的主要内容：</p><p>命名参数特性允许基于参数名称而不是参数位置来传递参数，这使得：</p><ol><li>可以跳过默认值</li><li>参数的传递可与顺序无关</li><li>参数的含义可以自我记录</li></ol><a id="more"></a><blockquote><p>其实这个特性的RFC早在2013年和2016年就有人建立过了，但一直没有通过或是实施，直到PHP8版本，该RFC终于得到机会再次启用，并且发起人是PHP内核的核心开发者Nikita Popov（nikic），nikic对此做了非常详细的调研，RFC全文字数差不多有三万字（相比于PHP的其它RFC而言已经是相当的多了），该RFC刚开始投票的时候还有一定的悬念（PHP社区的元老级人物对于新特性总是给出反对票），但很快赞同数就远超了2/3多数，目前RFC已投票通过。</p></blockquote><h2 id="命名参数的好处"><a href="#命名参数的好处" class="headerlink" title="命名参数的好处"></a>命名参数的好处</h2><h3 id="允许跳过默认值"><a href="#允许跳过默认值" class="headerlink" title="允许跳过默认值"></a>允许跳过默认值</h3><p>最显著的例子就是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">htmlspecialchars($string, ENT_COMPAT | ENT_HTML401, ini_get(<span class="string">'default_charset'</span>), <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">htmlspecialchars($string, double_encode: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>在没有命名参数特性之前，我们为了设置第四个参数<code>double_encode</code>，不得不给出第二第三个可选参数的默认值，我们可能需要查询文档或是编写冗长的代码，而有了命名参数特性之后，一切都简单了，并且哪怕某个参数的默认值发生了变化，代码也不会受到影响（虽然几乎不存在这样的情况，但某种意义上也是消除了硬编码）。</p><h3 id="参数含义的自我记录及传递顺序无关性"><a href="#参数含义的自我记录及传递顺序无关性" class="headerlink" title="参数含义的自我记录及传递顺序无关性"></a>参数含义的自我记录及传递顺序无关性</h3><p>比如对于某个我们我们不熟的函数（当然实际上来说，array系列函数都不熟的话可能连面试都通不过…）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_fill(value: <span class="number">50</span>, start_index: <span class="number">0</span>, num: <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>代码已经包含了对每个入参的意义的表达，并且传参顺序也可以任意改变。</p><h3 id="更简便的API调用"><a href="#更简便的API调用" class="headerlink" title="更简便的API调用"></a>更简便的API调用</h3><p>但我觉得这样的全命名写法一般来说是多此一举，容易造成书写风格的割裂，并且装了插件的编辑器或是IDE都能很好地显示出参数名。</p><p>所以这个特性最大的受益者应该是可选参数特别多或设计不合理的一些API，比如又臭又长的OpenSSL的API：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openssl_encrypt</span><span class="params">(string $data, string $method, string $password, int $options = <span class="number">0</span>, string $iv = <span class="string">''</span>, &amp;$tag = UNKNOWN, string $aad = <span class="string">''</span>, int $tag_length = <span class="number">16</span>)</span>: <span class="title">string</span>|<span class="title">false</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="更快捷的对象属性的初始化"><a href="#更快捷的对象属性的初始化" class="headerlink" title="更快捷的对象属性的初始化"></a>更快捷的对象属性的初始化</h3><p>此外有所受益的是对象属性的初始化：</p><p>其实在早前就有RFC探讨了如何更好地初始化对象属性，以使对象构造更符合人体工程学。写过C++的同学肯定很快就想到了「<a href="https://zh.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="noopener">初始化列表</a>」，PHP也有人专门为此建立了一个RFC「<a href="https://wiki.php.net/rfc/object-initializer" target="_blank" rel="noopener">对象初始化器</a>」，但是显然专门为此添加一个新语法并不那么值得，以反对票一边倒的结果被拒绝了。但现在我们有了命名参数以后，这个问题自然就解决了：</p><blockquote><p>以下展示还包含了另一个已落地的PHP8新特性，<a href="https://wiki.php.net/rfc/constructor_promotion" target="_blank" rel="noopener">构造函数属性升级</a>，我们可以在声明构造函数的参数的同时将其声明为对象的属性：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Part of PHP AST representation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        public string $name,</span></span></span><br><span class="line"><span class="function"><span class="params">        public ExprNode $default = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        public TypeNode $type = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        public bool $byRef = false,</span></span></span><br><span class="line"><span class="function"><span class="params">        public bool $variadic = false,</span></span></span><br><span class="line"><span class="function"><span class="params">        Location $startLoc = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        Location $endLoc = null</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::__construct($startLoc, $endLoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ParamNode(<span class="string">'test'</span>, variadic: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>来看看没有这两个特性之前我们需要以怎样繁琐的方式写出同等的代码吧，我保证你肯定不想按以下方式写代码，除非你已经在用某种代码生成器来帮你完成这一工作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamNode</span> <span class="keyword">extends</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> string $name;</span><br><span class="line">    <span class="keyword">public</span> ?ExprNode $default;</span><br><span class="line">    <span class="keyword">public</span> ?TypeNode $type;</span><br><span class="line">    <span class="keyword">public</span> bool $byRef;</span><br><span class="line">    <span class="keyword">public</span> bool $variadic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        string $name,</span></span></span><br><span class="line"><span class="function"><span class="params">        ExprNode $default = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        TypeNode $type = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        bool $byRef = false,</span></span></span><br><span class="line"><span class="function"><span class="params">        bool $variadic = false,</span></span></span><br><span class="line"><span class="function"><span class="params">        Location $startLoc = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        Location $endLoc = null</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;default = $default;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;type = $type;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;byRef = $byRef;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;variadic = $variadic;</span><br><span class="line">        <span class="keyword">parent</span>::__construct($startLoc, $endLoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ParamNode(<span class="string">'test'</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>或者有的人会选择用「数组」这个万金油来解决：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> string $name;</span><br><span class="line">    <span class="keyword">public</span> ExprNode $default;</span><br><span class="line">    <span class="keyword">public</span> TypeNode $type;</span><br><span class="line">    <span class="keyword">public</span> bool $byRef;</span><br><span class="line">    <span class="keyword">public</span> bool $variadic;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $name, array $options = [])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;default = $options[<span class="string">'default'</span>] ?? <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;type = $options[<span class="string">'type'</span>] ?? <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;byRef = $options[<span class="string">'byRef'</span>] ?? <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;variadic = $options[<span class="string">'variadic'</span>] ?? <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">parent</span>::__construct(</span><br><span class="line">            $options[<span class="string">'startLoc'</span>] ?? <span class="keyword">null</span>,</span><br><span class="line">            $options[<span class="string">'endLoc'</span>] ?? <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="keyword">new</span> ParamNode($name, [<span class="string">'variadic'</span> =&gt; <span class="keyword">true</span>]);</span><br></pre></td></tr></table></figure><p>有点小机灵，但是很遗憾，它的缺点更多：</p><ol><li>无法利用类型系统在传参时自动地检测（而是由于属性类型验证失败而报错）</li><li>你必须查看实现或是文档，且文档无法很好地记录它（没有公认的规范）</li><li>你可以悄无声息地传递未知选项而不会得到报错，这一错误非常普遍，曾经遇到有一个开发者将配置项名打错了一个字母，导致配置无法生效，却也没有得到任何报错，为此debug了一整天</li><li>没法利用新特性「构造函数属性升级」</li><li>如果你想将现有API切换到数组方式，你不得不破坏API兼容性，但命名参数不需要</li></ol><p>nikic非常自信地认为，相比而言，<strong>命名参数提供了同等便利，但没有任何缺点</strong>。</p><p>此外，RFC还简单延伸了一个备选方案，探讨如何解决历史代码中使用数组的缺陷：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> string $name;</span><br><span class="line">    <span class="keyword">public</span> ExprNode $default;</span><br><span class="line">    <span class="keyword">public</span> TypeNode $type;</span><br><span class="line">    <span class="keyword">public</span> bool $byRef;</span><br><span class="line">    <span class="keyword">public</span> bool $variadic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        string $name,</span></span></span><br><span class="line"><span class="function"><span class="params">        array [</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'default'</span> =&gt; ExprNode $default = null,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'type'</span> =&gt; TypeNode $type = null,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'byRef'</span> =&gt; bool $type = false,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'variadic'</span> =&gt; bool $variadic = false,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'startLoc'</span> =&gt; Location $startLoc = null,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'endLoc'</span> =&gt; Location $endLoc = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        ],</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;default = $default;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;type = $type;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;byRef = $byRef;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;variadic = $variadic;</span><br><span class="line">        <span class="keyword">parent</span>::__construct($startLoc, $endLoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然解决了类型安全问题，但无法解决默默接受未知选项的问题，并且还有很多需要考虑的难题，但不值得继续展开讨论。</p><h3 id="更好的注解兼容性"><a href="#更好的注解兼容性" class="headerlink" title="更好的注解兼容性"></a>更好的注解兼容性</h3><p>千呼万唤始出来，PHP8终于有了官方支持的注解特性，对于有些人来说这是比JIT还要让人激动的事情（因为对于他们来说JIT性能提升真的不是很大，PHP5到PHP7的跨越才是永远滴神），那么命名参数对注解又有什么好处呢？</p><p>曾经的路由注解可能是这样的（@Symfony Route）:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Route</span>("/api/posts/&#123;id&#125;", methods=&#123;"GET","HEAD"&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(int $id)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>有了官方注解以后可能是这样的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;Route(<span class="string">"/api/posts/&#123;id&#125;"</span>, [<span class="string">"methods"</span> =&gt; [<span class="string">"GET"</span>, <span class="string">"HEAD"</span>]])&gt;&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(int $id)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>那么势必造成API的向下不兼容，但有了命名参数以后，我们完全可以保持相同的API结构：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;Route(<span class="string">"/api/posts/&#123;id&#125;"</span>, methods: [<span class="string">"GET"</span>, <span class="string">"HEAD"</span>])&gt;&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(int $id)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于缺乏对嵌套注释的支持，仍然需要进行一些更改，但这会使迁移更加顺畅。</p></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>好了，看到这里很多人应该会觉得：命名参数真是个好东西！双脚赞成！<br>如果是，那么很巧，我也是这么想的，尤其是刚学编程，尝试用Python写一个WEB小程序的时候，我有被命名参数特性小小地惊艳到。<br>但是我们不得不知道的是，以上介绍「好处」的内容仅仅是RFC篇幅的小头部分，剩下的上万字内容也是大多数人所并不关心或不需要关心的实施细节。但我们必须以此思考获得的收益是否能弥补变动的成本，这也正是反对者所忧虑的部分。</p><p>我在这里简单罗列一下添加该特性需要考虑的问题们：</p><ul><li>是否支持动态指定命名参数？如果是，如何支持？使用何种语法？和现有语法有何种冲突？可能影响到的未来语法？</li><li>约束条件：如命名参数必须在必选参数之后；不得传递相同的命名参数；不得以命名参数形式覆盖相同位置的参数；不得使用未知的命名参数</li><li>可变参函数和参数解压缩规则</li><li>受影响的API们（不完全）：<code>func_get_args</code>，<code>call_user_func</code>系列，<code>__invoke()</code>，<code>__call()</code>和<code>__callStatic()</code>等等</li><li>继承期间变量名的更改：是否将其视为错误？是，造成向下不兼容？否，违反里式替换原则怎么办？应遵循何种模型，其它哪些语言的实现值得参考？</li><li>对于内核实现的影响（太多了，不扩展）</li></ul><p>有兴趣的同学可以自己阅读原版RFC，体会一下一个看似简单的新特性添加需要多么深入的考虑。最重要的是你还要将它们总结出来并说服绝大部分社区成员投赞成票，不同的人发起同样的主题的RFC也可能会有不同的结果。</p><h2 id="命名参数的困境"><a href="#命名参数的困境" class="headerlink" title="命名参数的困境"></a>命名参数的困境</h2><h3 id="修改参数名即是破坏向后兼容性"><a href="#修改参数名即是破坏向后兼容性" class="headerlink" title="修改参数名即是破坏向后兼容性"></a>修改参数名即是破坏向后兼容性</h3><p>CS领域中头号难题：命名！</p><p>如果说命名空间、类名、函数方法名已经让我们痛苦不堪，那么现在我们获得了数倍于之前的痛苦，好好想想你的参数名吧，因为你以后不能随便改它了，并且这将是下划线派和驼峰派的又一个战争点，谁输谁赢，谁是新潮流？</p><blockquote><p>PS：PHP内核开发者们正在对成千上万个内置函数的参数命名进行梳理工作…</p></blockquote><h3 id="文档和实现中的参数名称不匹配"><a href="#文档和实现中的参数名称不匹配" class="headerlink" title="文档和实现中的参数名称不匹配"></a>文档和实现中的参数名称不匹配</h3><p>参数命名的梳理的工作量翻倍了。</p><h3 id="继承的方法中不宜重命名参数名"><a href="#继承的方法中不宜重命名参数名" class="headerlink" title="继承的方法中不宜重命名参数名"></a>继承的方法中不宜重命名参数名</h3><p>该RFC建议遵循Python和Ruby的模型，在子方法中参数名如产生变动则默默接受，调用时使用不匹配的父方法的参数名可能会产生错误。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($foo, $bar)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($a, $b)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$obj = <span class="keyword">new</span> C;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Pass params according to C::test() contract</span></span><br><span class="line">$obj-&gt;test(a: <span class="string">"foo"</span>, b: <span class="string">"bar"</span>);     <span class="comment">// Works!</span></span><br><span class="line"><span class="comment">// Pass params according to I::test() contract</span></span><br><span class="line">$obj-&gt;test(foo: <span class="string">"foo"</span>, bar: <span class="string">"bar"</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>通常来说这没什么问题，但对于某些抽象设计来说就很不好了，以下代码将无法正常运作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($registrationCommand)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForgottenPasswordHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($forgottenPasswordCommand)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageBus</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addHandler</span><span class="params">(string $message, Handler $handler)</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHandler</span><span class="params">(string $messageType)</span>: <span class="title">Handler</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// handler可能是RegistrationHandler或ForgottenPasswordHandler</span></span><br><span class="line">        <span class="comment">// 它们为了更好地表达参数的意义而改变了参数名, 但也导致了我们无法通过message这个名字来调用它了</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;getHandler(get_class($message))-&gt;handle(message: $message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此已经有人提出了一个看起来更复杂的RFC：<a href="https://wiki.php.net/rfc/renamed_parameters" target="_blank" rel="noopener">Renamed Parameters</a></p><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><h3 id="简写语法"><a href="#简写语法" class="headerlink" title="简写语法"></a>简写语法</h3><p>我们常常会在栈上使用和参数名一样的变量名，那么我们可能可以简化这一行为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before:</span></span><br><span class="line"><span class="keyword">new</span> ParamNode(name: $name, type: $type, <span class="keyword">default</span>: $default, variadic: $variadic, byRef: $byRef);</span><br><span class="line"><span class="comment">// after:</span></span><br><span class="line"><span class="keyword">new</span> ParamNode(:$name, :$type, :$default, :$variadic, :$byRef);</span><br></pre></td></tr></table></figure><p>也适用于数组的解构（比较实用）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">[<span class="string">'x'</span> =&gt; $x, <span class="string">'y'</span> =&gt; $y, <span class="string">'z'</span> =&gt; $z] = $point;</span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">[:$x, :$y, :$z] = $point;</span><br></pre></td></tr></table></figure><p>这样我们可以废弃<code>compact</code>这种魔法一般的函数，刚学PHP的时候我好一会才理解这函数是干嘛的，作为函数，它的能力却和eval一样邪恶，这种特性应当是语法级别的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在我看来，这个特性的通过是必然的，这是一个迟早要实现的特性，对很多人来说更是一个姗姗来迟的特性。很多人不了解的是，PHP的RFC常常要求起草者自己想办法实现（包括找人代为实现），而不是直接进入投票环节通过后就强制要求PHP核心开发者实现（你行你上），因此有些RFC由于缺少靠谱的实施者所以就没有下文了。</p><p>PHP8这个大版本是去其糟粕、辞旧迎新的好契机，恰逢nikic这样年轻有为的改革派，一些本不可能落地的废弃项和新特性都已安全着陆（未来有空我会介绍一些PHP8中让人拍手称快的糟粕废弃项），PHP更加地「通用脚本语言」，而不再是「Personal Home Page」。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对「&lt;a href=&quot;https://wiki.php.net/rfc/named_params&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;命名参数RFC&lt;/a&gt;」的个人解读，先让我们来简单看下RFC的主要内容：&lt;/p&gt;
&lt;p&gt;命名参数特性允许基于参数名称而不是参数位置来传递参数，这使得：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以跳过默认值&lt;/li&gt;
&lt;li&gt;参数的传递可与顺序无关&lt;/li&gt;
&lt;li&gt;参数的含义可以自我记录&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="php8" scheme="http://www.twosee.cn/tags/php8/"/>
    
      <category term="rfc" scheme="http://www.twosee.cn/tags/rfc/"/>
    
  </entry>
  
  <entry>
    <title>漫谈Swoole协程与异步IO</title>
    <link href="http://www.twosee.cn/2020/06/12/swoole-coroutine-and-async-io/"/>
    <id>http://www.twosee.cn/2020/06/12/swoole-coroutine-and-async-io/</id>
    <published>2020-06-12T10:02:07.000Z</published>
    <updated>2021-05-19T08:58:44.437Z</updated>
    
    <content type="html"><![CDATA[<p>初次接触Swoole的PHP开发者多少都会有点雾里看花的感觉，看不清本质。一部分PHP开发者并不清楚Swoole是什么，只是觉得很牛掰就想用了，这种行为无异于写作文的时候总想堆砌一些华丽的辞藻或是引经据典来提升文章逼格，却背离了文章的主题，本末倒置，每一种技术的诞生都有它的原因，异步或是协程不是万能的银弹，你需要它的时候再去用它，而不是想用它而用它，毕竟编程世界的惯性是巨大的，这天下还是同步阻塞的天下。还有一部分开发者是对Swoole有了一些自己的见解，但对错参半，写出来的程序能跑，甚至也能上生产，但不是最优的，其中大部分问题都源于开发者无法将惯有的思维方式灵活转变。</p><a id="more"></a><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>首先协程的最简定义是<strong>用户态线程</strong>，它不由操作系统而是由用户创建，跑在单个线程（核心）上，比进程或是线程都更加轻量化，通常创建它只有内存消耗：假如你的配置允许你开几千个进程或线程，那么开几万个几十万个协程也是很轻松的事情，<strong>只要内存足够大，你可以几乎无止境地创建新的协程</strong>。在Swoole下，协程的切换实现是依靠双栈切换，即C栈和PHP栈同时切换，由于有栈协程的上下文总是足够的小，且<strong>在用户态便能完成切换</strong>，它的切换速度也总是远快于进程、线程，一般<strong>只需要纳秒级的CPU时间</strong>，对于实际运行的逻辑代码来说这点开销总是可以忽略不计（尤其是在一个重IO的程序中，通过调用分析可以发现协程切换所占的CPU时间非常之低）。</p><p>对于Swoole这样的有栈协程，你完全可以简单地将其看做是一个栈切换器，你可以在运行的子程序中随意切换到另一个子程序，底层会保存好被切走的协程的执行位置，回来时可以从原先的位置继续往下运行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ae01.alicdn.com/kf/He512eb2468f14fa6876ad1dd81854db1j.png" alt="coroutine.png" title="">                </div>                <div class="image-caption">coroutine.png</div>            </figure><center>Swoole多进程模型下的进程、线程、协程关系图</center><p>但这篇文章我们要谈的并不只是单单「协程」这一个概念，还隐含了关于异步网络IO一系列的东西，<strong>光有协程是什么也做不了的</strong>，因为Swoole的协程永远运行在一个线程中，想用它做并行计算是不可能的，运行速度只会因为创建开销而更慢，没有异步网络IO支持，你只能在不同协程间切来切去玩。</p><p>实际上PHP早就实现了协程，<code>yield</code>关键字就是允许你从一个函数中让出执行权，需要的时候能重新回到让出的位置继续往下执行，但它没有流行起来也有多种原因，一个是它的传染性，每一层调用都需要加关键字，另一个就是PHP没有高效可靠的异步IO支持，让其食之无味。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><blockquote><p>注：本文中提到的异步IO并非全为严格定义上的异步IO，更多的是日常化的表达</p></blockquote><p>简单了解了协程，再让我们来理解一下什么是异步IO吧。严格来说，在Unix下我们常说的异步并不是真异步，而是同步非阻塞，但是其效果和异步非常相近，所以我们日常中还是以异步相称。同步非阻塞和真异步区别在于：真异步是你提交读写请求后直接检查读写是否已完成即可，所以在Win下这样的技术被叫做「完成端口」，而同步非阻塞仅是操作不会长时间地陷入内核，但你需要在检查到可读或可写后，调用API同步地去拷贝数据，这会不可避免地陷入内核态，但read/write通常并不会阻塞太多的时间，从宏观上整个程序仍可以看作是全异步的。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">阻塞</th><th>非阻塞</th></tr></thead><tbody><tr><td style="text-align:center">同步</td><td style="text-align:center">write, read</td><td>read, write + poll / select / epoll / kqueue</td></tr><tr><td style="text-align:center">异步</td><td style="text-align:center">-</td><td>aio_read, aio_write, IOCP(windows)</td></tr></tbody></table><p>在实际使用中，「伪异步」的Reactor模型并不比Windows下IOCP的Proactor逊色，并且我更喜欢Reactor的可控性，当然为了追求极致的性能和解决网络和文件异步IO统一的问题，未来Linux的io_uring可能会成为新的趋势。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ae02.alicdn.com/kf/Ha6e560f59fec4700ac159a22479682b0s.png" alt="event_wait.png" title="">                </div>                <div class="image-caption">event_wait.png</div>            </figure><center>Reactor运行流程简图</center><p>我们可以通过上面的图片简单理解Reactor模型的运行流程，所谓的「异步」不过是多路复用带来的观感效果，你的程序不会阻塞在一个IO上，而是在无事可干的时候再阻塞在一堆IO上，即<strong>IO操作不在你需要CPU的时候阻塞你，你就不会感受到IO阻塞的存在</strong>。</p><blockquote><p>结合现实情景来说，以前你要买饭（IO操作），你得下楼去买，还得排队等饭店大厨做完才能取回家吃（IO阻塞），到了下一餐，你又得重复之前的操作，很是麻烦，而且越是繁忙的时候等的时间越长（慢速IO），你觉得一天到晚净排队了，极大地浪费了你写代码的时间（CPU时间）。现在有了外卖，你直接下单（异步请求）就可以继续专心写代码（非阻塞），你还可以一次定三份饭（多路IO），饭到了骑手打电话让你下楼取（事件触发），前后只花了不到几分钟（同步读写，如果是Proactor连取餐都省了，直接给你送上楼），周六晚上的九点，你终于合上电脑，觉得充实极了，因为你几乎一整周都在写代码（CPU利用率高）。</p></blockquote><h2 id="协程-异步-同步非阻塞编程"><a href="#协程-异步-同步非阻塞编程" class="headerlink" title="协程+异步=同步非阻塞编程"></a>协程+异步=同步非阻塞编程</h2><p>现在我们有了协程和异步，我们可以做什么呢？那就是异步的同步化。这时候有的开发者就会说了，诶呀好不容易习惯异步了，怎么又退回到同步了呢。这就是为什么有些开发者始终写不出最优的协程代码的原因，异步由于操作的完成不是立即的，所以我们需要回调，而回调总是反人类的，嵌套的回调更是如此。</p><p>而结合协程，消灭回调我们只需要两步：<strong>在发出异步请求之后挂起协程，在异步回调触发时恢复协程</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Swoole\Coroutine\run(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 1. 创建定时器并挂起协程#1</span></span><br><span class="line">    Swoole\Coroutine::sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. 协程恢复，继续向下运行退出，再次让出</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2. 协程#1让出，进入事件循环，等待1s后定时器回调触发，恢复协程#1</span></span><br><span class="line"><span class="comment">// 4. 协程#1退出并让出，没有更多事件，事件循环退出，进程结束</span></span><br></pre></td></tr></table></figure><p>短短的一行协程sleep，使用时几乎与同步阻塞的sleep无异，却是异步的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ($n = <span class="number">10</span>; $n--;) &#123;</span><br><span class="line">    Swoole\Coroutine::create(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Swoole\Coroutine::sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们循环创建十个协程并各sleep一秒，但实际运行可以发现整个进程只阻塞了一秒，这就表明在Swoole提供的API下，阻塞操作都由进程级别的阻塞变为了协程级别的阻塞，这样我们可以以很小的开销在进程内通过创建大量协程来处理大量的IO任务。</p><h2 id="协程代码编写思路"><a href="#协程代码编写思路" class="headerlink" title="协程代码编写思路"></a>协程代码编写思路</h2><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>当我们说到定时任务时，很多人第一时间都想到定时器，这没错，但是在协程世界，它不是最佳选择。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$stopTimer = <span class="keyword">false</span>;</span><br><span class="line">$timerContext = [];</span><br><span class="line">$timerId = Swoole\Timer::tick(<span class="number">1</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">global</span> $timerContext;</span><br><span class="line">    <span class="keyword">global</span> $timerId;</span><br><span class="line">    <span class="keyword">global</span> $stopTimer;</span><br><span class="line">    $timerContext[] = <span class="string">'data'</span>;</span><br><span class="line">    <span class="keyword">if</span> ($stopTimer) &#123;</span><br><span class="line">        var_dump($timerContext);</span><br><span class="line">        Swoole\Timer::clear($timerId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// if we want to stop it:</span></span><br><span class="line">$stopTimer = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>在异步回调下，我们需要以这样的方式来掌控定时器，每一次定时器回调都会创建一个新的协程，并且我们不得不通过全局变量来维护它的上下文。</p><p>如果是协程呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Swoole\Coroutine\run(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $channel = <span class="keyword">new</span> Swoole\Coroutine\Channel;</span><br><span class="line">    Swoole\Coroutine::create(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($channel)</span> </span>&#123;</span><br><span class="line">        $context = [];</span><br><span class="line">        <span class="keyword">while</span> (!$channel-&gt;pop(<span class="number">0.001</span>)) &#123;</span><br><span class="line">            $context[] = <span class="string">'data'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        var_dump($context);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// if we want to stop it, just call:</span></span><br><span class="line">    $channel-&gt;push(<span class="keyword">true</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完全同步的写法，从始至终只在一个协程里，不会丢失上下文，channel-&gt;pop在这里的效果相当于毫秒级sleep，并且我们可以通过push数据去停止这个定时器，非常的简单清晰。</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>由于开发者的强烈要求，Swoole官方曾经做了一个错误的决定，就是在Task进程中支持协程和异步IO。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ae02.alicdn.com/kf/H56ff04f9f58e4c6b91a1f3c9a9f77fc9H.png" alt="task.png" title="">                </div>                <div class="image-caption">task.png</div>            </figure><p>正如图中所示，Task进程最初被设计为用来处理无法异步化的任务，充当类似于PHP-FPM的角色（半异步半同步模型），这样各司其职，能够将执行效率最大化。</p><p>最早期的Swoole开发者，甚至直接将Swoole的Worker进程用于执行同步阻塞任务，这种做法并非没有可取之处，它比PHP-FPM下的效率更高，因为程序是持续运行，常驻内存的，少了一些VM启动和销毁的开销，只是需要自己处理资源的生命周期等问题。</p><p>此外就是使用异步API的开发者，他们会开一堆Task进程，将一些暂时无法异步化的同步阻塞任务丢过去处理。</p><p>而以上两种都是历史条件下正确并合适的Swoole打开方式。</p><p>但是还有一小撮开发者，一股脑地把所有任务都投递给Task进程，以为这样就实现了任务异步化，Worker进程除了接收响应和投递任务什么也不干，殊不知这就相当于每一个任务的处理多了<strong>两次数据序列化开销 + 两次数据反序列开销 + 两次IPC开销 + 进程切换开销</strong>。</p><p>而当协程逐渐成为新的趋势后，又有越来越多的社区呼声要求Task进程也能支持协程和异步IO，这样他们就可以将协程方式编写的任务投递到Task中执行。但异步任务可以很轻量地在本进程被快速处理掉，对Worker整体性能并不会有太大影响，他们这样的行为，也是典型的舍近求远。</p><h4 id="Task方式处理协程任务"><a href="#Task方式处理协程任务" class="headerlink" title="Task方式处理协程任务"></a>Task方式处理协程任务</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$server-&gt;on(<span class="string">'Receive'</span>, <span class="function"><span class="keyword">function</span><span class="params">(Swoole\Server $server)</span> </span>&#123;</span><br><span class="line">    <span class="comment"># 投递任务，序列化任务数据，通过IPC发送给Task进程</span></span><br><span class="line">    $task_id = $server-&gt;task(<span class="string">'foo'</span>); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment"># 切换到Task进程</span></span><br><span class="line"><span class="comment"># 接收并反序列化Worker通过IPC发送来的任务数据</span></span><br><span class="line">$server-&gt;on(<span class="string">'Task'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Swoole\Server $server, $task_id, $from_id, $data)</span> </span>&#123;</span><br><span class="line">  <span class="comment"># 使用协程DNS查询</span></span><br><span class="line">    $result = \Swoole\Coroutine::gethostbyname($data);</span><br><span class="line">    <span class="comment"># 序列化数据，通过IPC发送回Worker进程</span></span><br><span class="line">    $server-&gt;finish($result);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment"># 回到Worker进程</span></span><br><span class="line"><span class="comment"># 接收并反序列化Task通过IPC发送来的结果数据</span></span><br><span class="line">$server-&gt;on(<span class="string">'Finish'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Swoole\Server $server, int $task_id, $result)</span> </span>&#123;</span><br><span class="line">    <span class="comment"># 需要通过任务id才能确认是哪个任务的结果</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Task#&#123;$task_id&#125; finished"</span>;</span><br><span class="line">    <span class="comment"># 打印结果</span></span><br><span class="line">    var_dump($result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="协程方式写Task"><a href="#协程方式写Task" class="headerlink" title="协程方式写Task"></a>协程方式写Task</h4><blockquote><p>注：batch方法由swoole/library提供，内置支持需要Swoole-v4.5.2及以上版本，低版本可以自己使用Channel来调度</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span>;</span><br><span class="line"></span><br><span class="line">Coroutine\run(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment"># 并发三个DNS查询任务</span></span><br><span class="line">    $result = Coroutine\batch([</span><br><span class="line">        <span class="string">'100tal'</span> =&gt; <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Coroutine::gethostbyname(<span class="string">'www.100tal.com'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'xueersi'</span> =&gt; <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Coroutine::gethostbyname(<span class="string">'www.xueersi.com'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'zhiyinlou'</span> =&gt; <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Coroutine::gethostbyname(<span class="string">'www.zhiyinlou.com'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ]);</span><br><span class="line">    var_dump($result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出（API保证返回值顺序与输入顺序一致，不会因为异步而乱序）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="string">"100tal"</span>]=&gt;</span><br><span class="line">  string(<span class="number">14</span>) <span class="string">"203.107.33.189"</span></span><br><span class="line">  [<span class="string">"xueersi"</span>]=&gt;</span><br><span class="line">  string(<span class="number">12</span>) <span class="string">"60.28.226.27"</span></span><br><span class="line">  [<span class="string">"zhiyinlou"</span>]=&gt;</span><br><span class="line">  string(<span class="number">14</span>) <span class="string">"101.36.129.150"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常的简单易懂，不存在任何序列化或者IPC开销，并且由于程序是完全非阻塞的，大量的Task任务也不会对整体性能造成影响，所以说Task进程中使用协程或异步完全就是个错误，作为一个程序员，思维的僵化是很可怕的。</p><hr><p>读到这里大家应该也能明白，我们所谈论的协程化技术实际上可以看做传统同步阻塞和非阻塞技术的超集，非阻塞的技术让程序可以同时处理大量IO，协程技术则是实现了可调度的异步单元，它让异步程序的行为变得更加可控。如果你的程序只有一个协程，那么程序整体就是同步阻塞的；如果你的程序在创建某个协程以后不关心它的内部返回值，它就是异步的。</p><p>希望通过本文，大家能够加深对协程和异步IO的理解，写出高质量可维护性强的协程程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初次接触Swoole的PHP开发者多少都会有点雾里看花的感觉，看不清本质。一部分PHP开发者并不清楚Swoole是什么，只是觉得很牛掰就想用了，这种行为无异于写作文的时候总想堆砌一些华丽的辞藻或是引经据典来提升文章逼格，却背离了文章的主题，本末倒置，每一种技术的诞生都有它的原因，异步或是协程不是万能的银弹，你需要它的时候再去用它，而不是想用它而用它，毕竟编程世界的惯性是巨大的，这天下还是同步阻塞的天下。还有一部分开发者是对Swoole有了一些自己的见解，但对错参半，写出来的程序能跑，甚至也能上生产，但不是最优的，其中大部分问题都源于开发者无法将惯有的思维方式灵活转变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coroutine" scheme="http://www.twosee.cn/tags/coroutine/"/>
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
      <category term="async" scheme="http://www.twosee.cn/tags/async/"/>
    
  </entry>
  
  <entry>
    <title>使用Swoole协程一键代理PHP-FPM服务</title>
    <link href="http://www.twosee.cn/2020/04/17/swoole-fpm-proxy/"/>
    <id>http://www.twosee.cn/2020/04/17/swoole-fpm-proxy/</id>
    <published>2020-04-17T09:53:22.000Z</published>
    <updated>2021-05-19T09:00:27.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：陈曹奇昊</p><p>首发于公众号: 学而思网校技术团队</p></blockquote><p>一丶 什么是FastCGI</p><p>在Swoole最新发布的v4.5(RC)版本中，我们实现了一项非常有意思的新特性，那就是协程版本的FastCGI客户端。</p><p>那么什么是FastCGI呢？首先先来一个官方解释：</p><blockquote><p><strong>快速通用网关接口</strong>（<strong>Fast</strong> <strong>C</strong>ommon <strong>G</strong>ateway <strong>I</strong>nterface／<strong>FastCGI</strong>）是一种让交互程序与Web服务器通信的协议。</p></blockquote><p>其实很简单，大家使用PHP-FPM搭建服务的时候必然少不了前面架一个Nginx丶Apache或者IIS之类的东西作为代理，我们应用程序和代理通信的时候，可能会使用各种各样的协议（常见的比如浏览器使用的是HTTP/1.1，HTTP2，QUIC等），而代理的职责就是把各种协议的请求翻译成FastCGI来和PHP-FPM通信，这样PHP服务就无需关心各种类型协议的解析，而可以只关心处理请求本身的内容，且FastCGI是二进制协议，相较于HTTP1.x这样的文本协议，FastCGI可以说是非常高效。</p><p>实现了FastCGI客户端，那么我们就可以直接与PHP-FPM服务进行交互，但是这有什么用呢？</p><a id="more"></a><p>二丶Swoole中的Task进程</p><p>在一个Swoole的异步/协程服务中，我们无法容忍任何阻塞的存在，只要有一处调用阻塞，那么整个服务程序都会退化为阻塞程序，而此时如果我们又没有太多的资源去重构老项目，我们通常会选择使用Task进程来解决。</p><p>Task进程是Swoole异步服务器中专门设计用来执行同步阻塞程序的工作进程，我们可以很方便地调用<code>$server-&gt;task</code>方法去投递一个同步阻塞任务给Task进程并立即返回，Task进程在完成后再通知Worker进程接收结果，这样就构成了一个半异步半同步的服务器。</p><blockquote><p>我们需要大量的task进程来处理少量的同步阻塞任务，但只需要少量的Worker就可以处理大量的异步非阻塞任务，这就是多路IO复用技术带来的好处</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ae03.alicdn.com/kf/H80bce4512d9d4510bb71d71b57828f8cu.png" alt="task.png" title="">                </div>                <div class="image-caption">task.png</div>            </figure><p>虽然这样看起来已经非常方便了，但还是有一些不足，如：很多项目不单是同步阻塞，还只能运行在PHP-FPM语境下；此外，如果是协程服务器或是自己用socket写的服务器，就无法使用task功能。那么这时候协程版本的FastCGI就可以一展身手了。</p><p>三、使用协程FastCGI客户端调用PHP-FPM程序</p><p>首先我们本地得有一个正在运行的PHP-FPM，默认配置，知道它的地址即可</p><p>然后我们写一个世界级的Hello程序，存档为<code>/tmp/greeter.php</code>，我们只需在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "&lt;?php echo 'Hello ' . (\$_POST['who'] ?? 'World');" &gt; /tmp/greeter.php</span><br></pre></td></tr></table></figure><p>然后我们得确保我们已经安装了Swoole扩展，这时候我们只需要在命令行输入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php -n -dextension=swoole -r \</span><br><span class="line"><span class="string">"Co\run(function() &#123; \</span></span><br><span class="line"><span class="string">     echo Co\FastCGI\Client::call('127.0.0.1:9000', '/tmp/greeter.php',  ['who' =&gt; 'Swoole']); \</span></span><br><span class="line"><span class="string">&#125;);"</span></span><br></pre></td></tr></table></figure><p>就能得到输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Swoole</span><br></pre></td></tr></table></figure><p>这样一个最简单的调用就完成了，并且是协程非阻塞的，我们甚至可以通过多个客户端并发调用多个PHP-FPM提供的接口再提供给前端以提高响应速度。</p><p>我们可以先写一个sleep程序来模拟同步阻塞的PHP-FPM应用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="comment">#blocking.php</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> $_POST[<span class="string">'id'</span>] . PHP_EOL;</span><br></pre></td></tr></table></figure><p>协程FastCGI支持了PSR风格（并非规范）的操作方法，我们也可以自己手动构造一个HTTP请求传入，籍此我们可以灵活地构造任意FastCGI请求和PHP-FPM程序交互：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span>\<span class="title">FastCGI</span>\<span class="title">Client</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">FastCGI</span>\<span class="title">HttpRequest</span>;</span><br><span class="line"></span><br><span class="line">$s = microtime(<span class="keyword">true</span>);</span><br><span class="line">Coroutine\run(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($n = <span class="number">0</span>; $n &lt; <span class="number">2</span>; $n++) &#123;</span><br><span class="line">        Co::create(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                $client = <span class="keyword">new</span> Client(<span class="string">'127.0.0.1'</span>, <span class="number">9000</span>);</span><br><span class="line">                $request = (<span class="keyword">new</span> HttpRequest())</span><br><span class="line">                    -&gt;withScriptFilename(<span class="string">'/path/to/blocking.php'</span>)</span><br><span class="line">                    -&gt;withMethod(<span class="string">'POST'</span>)</span><br><span class="line">                    -&gt;withBody([<span class="string">'id'</span> =&gt; $n]);</span><br><span class="line">                $response = $client-&gt;execute($request);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"Result: &#123;$response-&gt;getBody()&#125;\n"</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Client\<span class="keyword">Exception</span> $exception) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"Error: &#123;$exception-&gt;getMessage()&#125;\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">$s = microtime(<span class="keyword">true</span>) - $s;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'use '</span> . $s . <span class="string">' s'</span> . <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>最终程序输出可能是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Result: <span class="number">1</span></span><br><span class="line">Result: <span class="number">0</span></span><br><span class="line"><span class="keyword">use</span> 1.0145659446716 <span class="title">s</span></span><br></pre></td></tr></table></figure><p>可以看到我们并发请求两个阻塞1s的接口，而总耗时仅需1s（实际上是<code>MAX(...所有接口响应时间)</code>），而且我们可以看到先请求不一定先返回，这同样也证明了这是一个非阻塞的程序。</p><p>当然这里要注意的是，你能并发的数量取决于你机器上PHP-FPM的工作进程数量，如果工作进程数量不足，那么请求不得不进行排队。</p><p>协程FastCGI客户端的到来，相当于我们的协程应用现在拥有了PHP-FPM这样一个无比强大稳定的进程管理器作为Task进程池来完成同步阻塞任务，借此我们可以解决很多问题，如：</p><p>有一些协议暂未受到Swoole协程的支持，但却有可用的同步阻塞的版本（MongoDB、sqlserver等），我们就可以通过它放心地投递给PHP-FPM来完成。</p><p>或是你有一个很老的PHP-FPM项目饱受性能困扰又因积重难返而无法快速重构，我们还是可以借助它来更平滑地将旧业务迁移到新的异步/协程服务器中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ae04.alicdn.com/kf/He9e340a33efb4e6c99b02361a61dba39Z.png" alt="fpm.png" title="">                </div>                <div class="image-caption">fpm.png</div>            </figure><p>四丶使用协程FastCGI一键代理WordPress</p><p>最强大的是协程FastCGI客户端还支持<strong>一键代理功能</strong>，可以将其它HTTP请求对象转化为FastCGI请求（目前只支持了Swoole\Http，后续可能加入PSR支持），也可以将FastCGI响应转化为HTTP响应，基于这个特性，我们可以做到代理世界上最好的博客程序：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Constant</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span>\<span class="title">FastCGI</span>\<span class="title">Proxy</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Http</span>\<span class="title">Response</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Http</span>\<span class="title">Server</span>;</span><br><span class="line"></span><br><span class="line">$documentRoot = <span class="string">'/path/to/wordpress'</span>; <span class="comment">// WordPress目录的绝对路径</span></span><br><span class="line">$server = <span class="keyword">new</span> Server(<span class="string">'0.0.0.0'</span>, <span class="number">80</span>, SWOOLE_BASE);</span><br><span class="line">$server-&gt;set([</span><br><span class="line">    Constant::OPTION_WORKER_NUM =&gt; swoole_cpu_num() * <span class="number">2</span>,</span><br><span class="line">    Constant::OPTION_HTTP_PARSE_COOKIE =&gt; <span class="keyword">false</span>,</span><br><span class="line">    Constant::OPTION_HTTP_PARSE_POST =&gt; <span class="keyword">false</span>,</span><br><span class="line">    Constant::OPTION_DOCUMENT_ROOT =&gt; $documentRoot,</span><br><span class="line">    Constant::OPTION_ENABLE_STATIC_HANDLER =&gt; <span class="keyword">true</span>,</span><br><span class="line">    Constant::OPTION_STATIC_HANDLER_LOCATIONS =&gt; [<span class="string">'/'</span>],</span><br><span class="line">]);</span><br><span class="line">$proxy = <span class="keyword">new</span> Proxy(<span class="string">'127.0.0.1:9000'</span>, $documentRoot);</span><br><span class="line">$server-&gt;on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Request $request, Response $response)</span> <span class="title">use</span> <span class="params">($proxy)</span> </span>&#123;</span><br><span class="line">    $proxy-&gt;pass($request, $response);</span><br><span class="line">&#125;);</span><br><span class="line">$server-&gt;start();</span><br></pre></td></tr></table></figure><p>撇开一些配置项的设置，整个代理的核心提取出来其实就只有这样一句代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Proxy(<span class="string">'127.0.0.1:9000'</span>, $documentRoot))-&gt;pass($request, $response);</span><br></pre></td></tr></table></figure><p>然后我们就可以在浏览器中访问localhost：</p><blockquote><p>图示为本地已搭建好的WordPress站点</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ae02.alicdn.com/kf/H4053f36cf44948769baf118eddad637b9.png" alt="wordpress.png" title="">                </div>                <div class="image-caption">wordpress.png</div>            </figure><p>五丶协程FastCGI客户端的背后</p><p>协程FastCGI客户端，我们可以在 <a href="https://github.com/swoole/library" target="_blank" rel="noopener">https://github.com/swoole/library</a> 仓库查看它的源码，在README中可以找到现成的Docker构建命令和配套演示程序来让我们快速上手体验它。</p><p>此外，通过查看源码我们不难发现，协程FastCGI客户端是完全使用PHP代码编写、基于协程Socket实现的，由于FastCGI是高效的二进制协议，我们使用PHP代码来进行解析也不会有太大的开销（而HTTP1.x这样的文本协议就不行，越是人类友好的协议，对机器来说就越不友好）。</p><p>包括很多Swoole的其它组件如：WaitGroup、全自动连接池、协程Server等等，都是使用PHP编写的，PHP编写的组件具有内存安全、开发高效的特点，并且Swoole内核将这些PHP组件内嵌到了扩展中，开发者是无感知的，安装扩展后就能立即使用这些组件而无需引入额外的包管理。</p><p>即使FastCGI客户端是纯PHP编写的，压测性能和nginx仍在一个量级，这也证明了PHP的性能瓶颈并不总是在于PHP代码本身，很多时候是由于同步阻塞的IO模型导致的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ae03.alicdn.com/kf/H7c3392410e354debbff3c2e5111eb24fW.png" alt="bing.png" title="">                </div>                <div class="image-caption">bing.png</div>            </figure><p>目前PHP编写的组件在Swoole中的占比还不高，未来我们希望能引入更多的PHP编写的内部组件来解决功能性的需求，而只有PHP难以满足的一些高性能的需求（如各种复杂协议的处理）才考虑使用C++实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：陈曹奇昊&lt;/p&gt;
&lt;p&gt;首发于公众号: 学而思网校技术团队&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一丶 什么是FastCGI&lt;/p&gt;
&lt;p&gt;在Swoole最新发布的v4.5(RC)版本中，我们实现了一项非常有意思的新特性，那就是协程版本的FastCGI客户端。&lt;/p&gt;
&lt;p&gt;那么什么是FastCGI呢？首先先来一个官方解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;快速通用网关接口&lt;/strong&gt;（&lt;strong&gt;Fast&lt;/strong&gt; &lt;strong&gt;C&lt;/strong&gt;ommon &lt;strong&gt;G&lt;/strong&gt;ateway &lt;strong&gt;I&lt;/strong&gt;nterface／&lt;strong&gt;FastCGI&lt;/strong&gt;）是一种让交互程序与Web服务器通信的协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实很简单，大家使用PHP-FPM搭建服务的时候必然少不了前面架一个Nginx丶Apache或者IIS之类的东西作为代理，我们应用程序和代理通信的时候，可能会使用各种各样的协议（常见的比如浏览器使用的是HTTP/1.1，HTTP2，QUIC等），而代理的职责就是把各种协议的请求翻译成FastCGI来和PHP-FPM通信，这样PHP服务就无需关心各种类型协议的解析，而可以只关心处理请求本身的内容，且FastCGI是二进制协议，相较于HTTP1.x这样的文本协议，FastCGI可以说是非常高效。&lt;/p&gt;
&lt;p&gt;实现了FastCGI客户端，那么我们就可以直接与PHP-FPM服务进行交互，但是这有什么用呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
      <category term="fpm" scheme="http://www.twosee.cn/tags/fpm/"/>
    
  </entry>
  
  <entry>
    <title>PHP变量浅析</title>
    <link href="http://www.twosee.cn/2019/07/22/php-var/"/>
    <id>http://www.twosee.cn/2019/07/22/php-var/</id>
    <published>2019-07-22T03:11:42.000Z</published>
    <updated>2021-05-17T10:07:55.878Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇很久以前写的文章（大概是两年前），一直没发，可能囿于技术水平，有一些错误，已经草草修正了一些内容，如仍有写歪来的地方，欢迎拍砖。</p><hr><p>我们每天都在和变量打交道，PHP的变量足够简单，当静态语言的初学者还在将类型推导（如C++写”auto foo = 1”将自动推导foo为int类型）惊奇不已的时候，动态语言的开发者早已习以为常了。</p><p>但天下没有白吃的午餐，变量使用起来越方便，背后的原理就越复杂，你以为你已经能将变量运用自如，但其实你只是个会开车的普通司机，你并不懂车。而你若想要成为PHP世界的专业级赛车手，赛车的每个零部件到组装到核心引擎的运转，你都必须了如指掌。</p><a id="more"></a><h2 id="变量修饰符"><a href="#变量修饰符" class="headerlink" title="变量修饰符"></a>变量修饰符</h2><p>说到PHP变量，我们首先会想到那个令开发者们又爱又恨的<code>$</code>符。不管是喜欢它还是讨厌它的开发者，可能都不是很清楚为什么要用<code>$</code>来表示变量。</p><p>很多人都知道PHP很多的设计都受到了C的影响，毕竟PHP内核就是用C写的，就比如很多基础的函数名和C是一模一样的。但PHP还有一个很重要的前辈是Perl，开发者们普遍认为PHP用<code>$</code>符修饰变量是从Perl那里学来的，还有诸如”.”连接字符串，用”=&gt;”来设置数组(哈希)键值，”-&gt;”访问对象成员等。</p><p>早期的PHP还在写模板的时候，<code>$</code>也为程序员带来了很多好处，如直接在字符串内嵌入变量，甚至很多人并不知道它配合花括号还可以这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$o = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span><span class="params">(string $name)</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello &#123;$name&#125;!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&#123;$o-&gt;greet('PHP')&#125;"</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello PHP!</span><br></pre></td></tr></table></figure><p>或是可变变量</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$foo = <span class="string">'bar'</span>;</span><br><span class="line">$$foo = <span class="string">'char'</span>;</span><br><span class="line">var_dump($bar);</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(4) &quot;char&quot;</span><br></pre></td></tr></table></figure><br>此外，<code>$</code>符修饰的变量永远不会和语言关键字冲突。</p><p>当然，这只能算是一些冷知识或是奇技淫巧，作为我们本篇的开胃菜。想要对PHP变量有新的认识，我们得先从表象入手，由浅入深，最后深入理解它的原理。</p><h1 id="PHP的栈和堆"><a href="#PHP的栈和堆" class="headerlink" title="PHP的栈和堆"></a>PHP的栈和堆</h1><p>为了搞清楚变量分配，我们还需要要了解PHP中的栈和堆，同样是内存，划分为栈和堆自然有分配上效率的原因。</p><p>我们事先准备好一块足够大的内存，这就是栈，程序运行时大量的变量符号所需的内存都在栈上挨个分配，函数调用时直接入栈出栈无需每次申请内存，这样就非常快。PHP甚至能事先计算好某个函数调用时需要多大的栈内存，内存不足时便会自动进行栈扩容。</p><p>我们运行时可能要创建一些字符串或者对象，它们可能会非常大，而且充满不确定性，这时候我们就需要向内存管理器动态地申请一块内存，有时候甚至可能会因为内存限制分配失败，这里所分配的内存就是堆区上的内存。</p><blockquote><p>TIP： PHP的栈区是在操作系统的堆区上，扩容时也可能会由于系统内存不足失败，但这很少发生，当系统内存不足时会直接把占用太多内存的进程强制kill掉。</p></blockquote><h2 id="变量的存储方式"><a href="#变量的存储方式" class="headerlink" title="变量的存储方式"></a>变量的存储方式</h2><p>首先我们要了解什么是动态语言，动态语言即是在“运行时”可以根据某些条件改变自身结构，如动态注册甚至替换函数等等；而静态语言一般在编译期就完成了函数定义、类型检查等事情。容易混淆的是，<strong>语言的强弱类型和动静态与否并没有关系</strong>，区别在于类型检查的时机：静态语言一般在编译期就进行了类型检查，而动态语言需要在运行时才能检查类型。</p><p>综上可知，PHP是一门典型的弱类型的动态语言，因为PHP中的变量，<strong>不仅是“量值”可变，“量的类型”也是可以随时变化的</strong>。PHP的变量无需声明，写即可用，非常方便，但这也造成了PHP内核无法在编译期间推断出所有变量的类型，如某个函数的运行结果依赖了外部数据，它的返回值可能是多种类型的，这样就无法在编译期有针对性地优化，而是在运行时不断地做检查。而PHP8想要实现JIT提升性能，就必须克服这个问题，所以PHP正不断地引入强类型特性，随着类型系统愈发完善，开发者也在有意识地<strong>减少动态类型的滥用</strong>，代码质量不断提高。</p><p>知道了这些以后，我们可以肯定地推测，PHP变量和其它静态语言变量的存储方式是不同的。如我们在C语言中声明一个字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span> = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>那么显而易见这个字符串占用了6个字节的内存（字符串长度 + \0终止符），这一点你可以用sizeof来验证。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%zu"</span>, <span class="keyword">sizeof</span>(<span class="string">"hello"</span>)); <span class="comment">// 输出6</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注：PHP中的sizeof是count的别名，和占用内存并没有关系</p></blockquote><p>而由于PHP7增加了很多优化机制，我们并不能在PHP中直观地看见变量和内存的关系（这里指使用memory_get_usage函数，具体的原因我们将在后文讲到）。但我们可以通过分析PHP的内核，即Zend虚拟机的底层源码来推断。</p><p>如果你有一点C语言基础，那么你应该知道结构体、联合体和一些数据类型，我们可以来看看PHP变量在C底层的结构定义（因为是Zend引擎实现，所以被称作zval）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zval</span> &#123;</span></span><br><span class="line">  <span class="comment">/* 值 （8字节）*/</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    zend_long        lval; <span class="comment">// 对应int类型</span></span><br><span class="line">    <span class="keyword">double</span>           dval; <span class="comment">// 对应float类型</span></span><br><span class="line">    zend_string      *str; <span class="comment">// 对应string类型</span></span><br><span class="line">    zend_array       *arr; <span class="comment">// 对应array类型</span></span><br><span class="line">    zend_object      *obj; <span class="comment">// 对应object类型</span></span><br><span class="line">    zend_resource    *res; <span class="comment">// 对应resource类型</span></span><br><span class="line">    zend_reference   *ref; <span class="comment">// 对应引用类型</span></span><br><span class="line">  &#125; value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 类型信息 (4字节) */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    zend_uchar    type;    <span class="comment">// 存储了变量的类型，以找到对应的value</span></span><br><span class="line">    zend_uchar    type_flags; <span class="comment">// 内存管理使用，可忽略</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      extra;</span><br><span class="line">  &#125; type_info;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 额外信息 (4字节，内存对齐冗余) */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>      extra;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是PHP的一个变量在底层的内存布局，这里过滤了一些暂时用不到的信息，简化了它的结构，看起来更加清晰，总的来说有三个部分：<strong>值、类型、额外信息</strong>，构成了PHP变量的容器”zval”。<br>我们先来计算一下它在64位机器上占用的内存大小：首先value是一个联合体，它的尺寸取决于它们中最大的那个，不管是long、double、还是指针类型，都正好是占用64位即8个字节；其次是类型信息结构体，一个无符号字符（char）1个字节，类型和类型标志加上额外冗余共计4个字节；最后还有一块额外冗余的值，也是4字节，一共加起来是<strong>16字节</strong>，这就是一个变量本身所占用的内存大小。</p><blockquote><p>不知道为什么有额外信息冗余的可以课外了解一下内存对齐的知识</p></blockquote><p>当一个变量是int或者float类型的时候，它占用的内存就正好是16字节，因为这个值是直接存在变量本身的内存中的，而变量的内存又是在PHP的栈区上；当一个变量是字符串、数组、对象、资源的时候，它的value存储的是一个指针，指针指向了真正变量值的内存地址，它是分配在堆区上的。</p><p>而我们所谈论的字符串，即zend_string的结构体又长这样，包含了三个固定属性：<strong>引用计数信息、哈希值、长度</strong>，在64位系统上一共是24个字节（refcount是4字节的，但是对齐到了8字节），而value的长度是根据字符串长度动态确定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zend_string</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>          refcount; <span class="comment">// 引用计数，表示这个字符串被引用了几次</span></span><br><span class="line">  zend_ulong        hash;     <span class="comment">// 哈希缓存，在字符串对比时能够极大提高速度</span></span><br><span class="line">  <span class="keyword">size_t</span>            length;   <span class="comment">// 字符串长度，确保了字符串的二进制安全</span></span><br><span class="line">  <span class="keyword">char</span>              value[length];  <span class="comment">// 字符串内容，此处表示它的内存和这个结构体的内存是连续的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>已知PHP的字符串也是zero-termination（零结尾）的，那么我们可以推测出，一个字符串变量，就需要占用 “zval + zend_string + 字符串长度 + 1” 这么多的字节，以“hello”来计算就是46个字节（可能还需要内存对齐），而不是C语言中明明白白简简单单的6个字节。</p><h2 id="PHP字符串变量的写时分离"><a href="#PHP字符串变量的写时分离" class="headerlink" title="PHP字符串变量的写时分离"></a>PHP字符串变量的写时分离</h2><p>定义一个8字节的int类型，需要占用16字节的内存（PHP5时代甚至高达32字节，感谢PHP7的优化），定义一个长度为5的字符串，却要占用46个字节的内存，你可能不禁感到使用动态语言的内存代价十分昂贵。</p><p>事实确实如此，但也不尽然。</p><p>首先我们来看一个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="string">'hello'</span>;</span><br><span class="line">$b = $a;</span><br></pre></td></tr></table></figure><p>我们都知道，PHP默认总是传值赋值，那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。被赋值的变量所持有的值，可以称作是副本。<br>那么把<code>$a</code>赋值给<code>$b</code>，是否就会产生一个<code>$a</code>的副本，一共占用两倍的内存呢？</p><p>其实不然，因为<strong>PHP采用了Copy-On-Write（写时复制）的机制，并使用引用计数管理内存</strong>。</p><p>已知zval上的zend_string是一个指针，那么其它zval也可以用指针指向这个字符串。让我们拆解着看：</p><p>当我们声明<code>$a</code>并赋值时：</p><ol><li>在栈上符号表中分配了一个<code>$a</code>的zval</li><li>在堆区申请内存，创建一个zend_string（24字节头部信息+5+1字节内容），拷贝”hello”给zend_string-&gt;value，设置length为5</li><li>赋值，设置<code>$a</code>的zval-&gt;value.str = 刚才创建zend_string</li></ol><p>当我们声明<code>$b</code>并将<code>$a</code>赋值给$b的时候，实则发生了以下事情:</p><ol><li>在栈上符号表中分配了一个<code>$b</code>的zval</li><li>拷贝了<code>$a</code>的zval给<code>$b</code>的zval，现在它们指向同一个zend_string</li><li>zend_string-&gt;refcount（引用计数）加1</li></ol><p>这时候我们知道了，字符串赋值并没有产生字符串的内存拷贝，只是拷贝了zval和增加了引用计数，两个变量都指向了同一个字符串。这样赋值的代价就非常小，几乎可以忽略不计。</p><p>如果我们修改了<code>$b</code>的字符串值呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$b .= <span class="string">' world'</span>; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>那么此时就会发生写时复制，也叫<strong>写时分离</strong>，即<code>$a</code>和<code>$b</code>不再指向同一个zend_string，这时候会创建一个真正的zend_string的副本给<code>$b</code>，而原来zend_string的引用计数减为1。<br>需要注意的是，如果字符串的内容非常大，那么哪怕只是对<code>$b</code>追加了一个字符，也将会占用双倍于原来以上内存，代价十分昂贵。</p><h2 id="PHP引用计数机制"><a href="#PHP引用计数机制" class="headerlink" title="PHP引用计数机制"></a>PHP引用计数机制</h2><p>刚才提到了引用计数这个东西，就不得不展开说一下，正如我们所见，zend_string的头部有一个refcount属性，表示这个zend_string被几个zval所引用了，当我们将它赋值给某个zval时，它就加1，当某个持有它的zval不再被用到时，它就减1，当它变为0的时候，表示再也没有zval指向它了，那么PHP内核就会根据zval的类型，调用相应的释放函数来释放它的内存。</p><p>PHP中常见的拥有引用计数的类型有：string、array、object，它们的数据结构的头部都是refcount。</p><p>其中，object大家都知道有构造、析构函数，当object的引用计数为0时，先会调用析构函数，再释放内存。</p><p>基于引用计数的内存管理方式好处显而易见：<strong>简单、可靠、实时回收、不会造成程序长时间停顿、还可以清晰地标明每一个变量的生命周期</strong>。但它也不是没有缺点，频繁且大量地更新计数也会有一定的开销，原始的引用计数也无法解决循环引用的问题。</p><h2 id="PHP数组变量的写时分离"><a href="#PHP数组变量的写时分离" class="headerlink" title="PHP数组变量的写时分离"></a>PHP数组变量的写时分离</h2><p>数组和字符串一样，都是在堆区分配内存，并由zval指向一个zend_array，zend_array的头部也有引用计数。</p><p>你可以暂且把数组简单看做一堆zval的集合，当数组发生写时分离时，只会拷贝数组本身，也就是产生一个新的zval的集合，所有数组上的有引用计数的zval，其计数都会加1，而不是数组上的每一个元素都会产生写时分离。</p><h2 id="PHP数字变量的值拷贝"><a href="#PHP数字变量的值拷贝" class="headerlink" title="PHP数字变量的值拷贝"></a>PHP数字变量的值拷贝</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = $a;</span><br></pre></td></tr></table></figure><p>这个例子里，<code>$a</code>和<code>$b</code>的zval.value.lval上都单独存储了一个8字节的0x00000001，而不是像字符串那样另有指向，因为zval只有16字节，且它总是在栈区上分配，无需单独申请一块内存，所以当我们赋值一个数字的时候，总是将整个zval拷贝过去，这样的拷贝非常快代价几乎可以忽略不计，并且省去了引用计数的管理。</p><h2 id="PHP无值布尔变量"><a href="#PHP无值布尔变量" class="headerlink" title="PHP无值布尔变量"></a>PHP无值布尔变量</h2><p>按照常人的理解，PHP的zval的布尔值设计一定是定义一个type为IS_BOOL，然后value中有一个zend_bool的值，为0时表示false，为1时表示true。</p><p>可事实上并不是这样，PHP使用type这一个量来实现布尔值，<strong>布尔型的zval对应了两种type：IS_TRUE和IS_FALSE</strong>。</p><p>这样在赋值一个变量为布尔值时，只需要改变zval的type，而不需要去修改zval的value。</p><h2 id="PHP的NULL"><a href="#PHP的NULL" class="headerlink" title="PHP的NULL"></a>PHP的NULL</h2><p>NULL和布尔值一样，只有type，没有value。这里又有一个常见的误区，即<strong>unset变量和设置一个变量为NULL是两种不一样的操作</strong>，unset是从符号表或数组中删除某个变量，而赋值null是将变量的type置为IS_NULL，更具体的区别，我们将在后续模块中讲到，这将涉及到一种隐藏类型的变量——UNDEF变量。</p><h2 id="PHP变量引用"><a href="#PHP变量引用" class="headerlink" title="PHP变量引用"></a>PHP变量引用</h2><p>我们已知zval只是一个变量的容器，它在管理字符串、数组、对象、资源的时候，都是采用指针指向的方式，而我们又常说，<strong>object（对象）总是传引用的</strong>，但这并不代表存储object的zval是一个引用变量。</p><p>结合我们上述分析，可以推出，对象在传递的时候，同样会拷贝zval，但是<strong>任我们如何操作对象，也永远不会发生写时分离产生新的对象</strong>，如此简单就实现了对象永远是”传引用”的机制了。</p><p>resource类型（资源）也是一样，略有不同的就是，资源都是向操作系统申请的，它无法被clone，即无法生成副本。</p><h2 id="PHP引用变量"><a href="#PHP引用变量" class="headerlink" title="PHP引用变量"></a>PHP引用变量</h2><p>引用变量是相对罕见的，它会引入一些复杂性，有时候难以拿捏。如<strong>最常见的错误就是将对象类型的变量进行引用赋值或引用传递</strong>，显而易见的多此一举。</p><p>引用变量和对象传引用不同，引用是符号表别名，它不是和object那样多个zval指向同一个对象的指针，而是引用变量的zval指向了被引用的zval，所有的修改都相当于对被引用的zval操作，唯一的例外是对引用变量使用unset，它不会删除被引用zval的值，而是解除了对其的引用。</p><p>由于写时拷贝的存在和PHP的一些优化措施，引用变量显得有些鸡肋，我们通常也不建议使用引用，让我们来看两个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(string $a)</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a . <span class="string">'bar'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(string &amp;$a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $a .= <span class="string">'bar'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种写法会有什么性能差异吗？有一定C++基础的人或许不难看出，第二种写法在C++中的同等例子或许可以减少一次对象构造和内存拷贝，但在PHP中并不成立。</p><ol><li>当传入的<code>$a</code>引用计数为1时，在例一中，PHP会将字符串的改动直接作用于传入变量本身并返回，不会发生写时分离，效果和例二没有区别（这就是引用计数的优点之一，可以实时判断变量的生命周期状态，减少内存拷贝）。</li><li>当传入的<code>$a</code>引用计数大于1时，对于字符串的修改又引发了写时分离，例1和例2都会产生一个新的字符串副本。</li></ol><p>那么问题又来了，为什么PHP有些内置函数参数是引用的呢？比如非常常见的sort系列函数——那是因为这些函数的出现早于PHP4实现写时复制的版本，那时候的PHP还称不上严格意义上的语言。</p><p>所以在PHP中，<strong>随意滥用引用是不好的，不要期望引用能够提高性能，它多数时候只会惹是生非</strong>。</p><p>但引用肯定也有用武之地，那么什么时候我们才该使用引用呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> &amp;$value) &#123;</span><br><span class="line">    $value += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> $index =&gt; $value) &#123;</span><br><span class="line">    $array[$index] += <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果你尝试拿一个大的<strong>关联数组</strong>做一下性能测试，就可以发现第一种的情况的运行速度优于第二种，为什么非得是关联数组呢？因为第二种方式每次增加键值时，都会多一次哈希查找的步骤。但如果不是关联数组，又有什么区别呢？这里有个新的知识点，我们留到后续数组的章节再来讨论。<br>此外，类似array_walk这样的数组遍历函数，当我们想修改数组内的值时，callback定义的参数通常也是加引用符的，若<strong>只是只读地访问变量，我们永远都不需要加引用</strong>。</p><h2 id="PHP变量的循环引用"><a href="#PHP变量的循环引用" class="headerlink" title="PHP变量的循环引用"></a>PHP变量的循环引用</h2><p>当我们已经初步了解了上述知识以后，我们就可以来思考这样一个问题，如果一个变量自己引用了自己，那么会发生什么？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$foo = [];</span><br><span class="line">$foo[] = &amp;$foo;</span><br><span class="line">var_dump($foo);</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  &amp;<span class="keyword">array</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    [<span class="number">0</span>]=&gt;</span><br><span class="line">    *RECURSION*</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以由RECURSION看出来foo变量循环引用了自身，如果无限制递归地打印，将会变成死循环输出。<br>而当foo变量不再被用到时，它的引用计数减一，但由于它的内部自己引用了自己，它将永远保持最低为1的引用计数，将无法被释放。在PHP5.3以前，这种情况没有解决方案，只能依靠FPM模型下的重启VM解决，如果是常驻内存的应用，这种情况将会产生持续的内存泄漏。这也是前文提到的原始引用计数下无法解决的问题之一。</p><p>好在PHP5.3后引入了垃圾回收机制，通过一种同步回收算法，定量地深度度优先遍历疑似垃圾，进行模拟删除和模拟恢复，以此筛选得出循环引用的垃圾，然后进行内存回收，解决了这个问题。</p><p>但我们在开发中仍需重视循环引用的问题，降低垃圾回收的负担。</p><h2 id="PHP变量的隐式转换、整数溢出"><a href="#PHP变量的隐式转换、整数溢出" class="headerlink" title="PHP变量的隐式转换、整数溢出"></a>PHP变量的隐式转换、整数溢出</h2><p>前文我们已经说了PHP的变量是动态弱类型的，那么就意味着它允许变量之间的隐式转换。</p><p><strong>所谓隐式转换，就是指当你将A类型的变量当作B类型来操作时，A类型将会自动转换为B类型，而不是产生一个类型错误</strong>。</p><p>PHP底层定义了一系列convert方法来进行这样的转换，convert系列方法会先switch判断zval里存储的type，跳跃到对应的处理流程进行转换。</p><p>比较常见的隐式转换就是数字和字符串之间的转换，这里PHP巧妙地用“.”符号来表示字符串拼接，“+”符号来表示加法运算，在某些场景下很好地避免了错误的隐式转换类型。</p><p>此外，PHP的标量类型尽管在引入了函数类型定义的情况下，仍允许隐式转换，如当你将一个string类型的变量传给了一个限制了int类型的参数，string将会自动转为int，除非你在文件开头定义”declare(strict_types=1);”，这也是部分高质量开源库的硬性要求，这种做法在未来的PHP中将有很大受益。</p><p>类似PHP这样的动态类型语言还有一个通病就是不方便解决整数溢出问题，PHP的int型是有符号整数，比无符号的范围要小很多，大部分语言的解决方法就是在溢出时将数值转换成浮点型，PHP也是这么做的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$foo = PHP_INT_MAX;</span><br><span class="line">var_dump($foo); <span class="comment">// 输出 int(9223372036854775807)</span></span><br><span class="line">$foo++;</span><br><span class="line">var_dump($foo); <span class="comment">// 输出 float(9.2233720368548E+18)</span></span><br><span class="line">$foo -= PHP_INT_MAX;</span><br><span class="line">var_dump($foo); <span class="comment">// 输出 float(0) 出现丢失</span></span><br></pre></td></tr></table></figure><p>但我们都知道，浮点型的精度有限，所以在某些时候，我们可能需要借助bcmath扩展来处理大数字。<br>此外值得一提的是，从数据库取大的整型数据这样的场景中，<strong>超出范围的整型变量PHP底层将会将其变成字符串型，以确保不会发生信息丢失。</strong></p><h2 id="PHP变量的比较"><a href="#PHP变量的比较" class="headerlink" title="PHP变量的比较"></a>PHP变量的比较</h2><p>作为一个有经验的PHP程序员，不可能不知道强等于（===）和弱等于（==）的区别。合格的PHPer大都首选强等于，加之PHP类型系统的不断完善，“declare(strict_types=1);”甚至也成了必选。</p><p>但很多开发者并没有注意到, PHP中还存在着使用松散比较的函数，如最常用的”in_array”，需要设定第三个参数为true，甚至最基础的switch语句使用的也是松散比较，稍不注意，就会陷入变量松散比较的陷阱中。</p><blockquote><p>以下返回结果都是true，你所忽视的变量松散比较正在破坏着你的程序逻辑<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump(in_array(<span class="string">'foo'</span>, [<span class="number">0</span>]));</span><br><span class="line">var_dump(in_array(<span class="number">0</span>, [<span class="string">'bar'</span>]));</span><br><span class="line">var_dump(in_array(<span class="keyword">null</span>, [[]]));</span><br></pre></td></tr></table></figure><br>这里还是涉及到了类型转换的知识，当两个不同类型的变量进行松散比较时，PHP内核总是按照特定规则将它们转为同一类型的变量，再进行比较。<br>但在PHP8中，某些不安全的比较行为可能会得到校正，如字符串总是等于0，这一改动会从语言的根本导致向下不兼容，但这是一个正确的方向，PHP8应该有这样的勇气去除糟粕，才能成大事。</p></blockquote><blockquote><p>相关RFC: <a href="https://wiki.php.net/rfc/string_to_number_comparison?fileGuid=mGhZJpuH2DsRCwY2" target="_blank" rel="noopener">https://wiki.php.net/rfc/string_to_number_comparison</a></p></blockquote><p>而强类型比较则是在弱比较的基础上，还判断了两个变量是否是相同类型的，因此它<strong>不会引发任何隐式的类型转换。</strong></p><p>除此之外，”==”的语义自然是”equal”，而“===”的语义实际上是”identical”，也就是“同一的“，对于PHP的一些基本类型，如数字、字符串、数组等，两个变量的值相等即可，但对于对象类型的比较，则要求是”同一个对象“，如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(<span class="keyword">new</span> stdClass === <span class="keyword">new</span> stdClass);</span><br></pre></td></tr></table></figure><p>这个例子中虽然两个对象别无二致，但由于不是同一个对象，将会返回false。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>PHP的变量说简单，是真的简单，无需声明，想用就用，或许很多开发者长久以来从未思考过变量背后的运作原理，只是一味地使用。实际上zva的设计十分精妙，用繁浩的底层代码来隐藏了编程的复杂性，让PHP开发者享受到了快乐开发的乐趣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇很久以前写的文章（大概是两年前），一直没发，可能囿于技术水平，有一些错误，已经草草修正了一些内容，如仍有写歪来的地方，欢迎拍砖。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们每天都在和变量打交道，PHP的变量足够简单，当静态语言的初学者还在将类型推导（如C++写”auto foo = 1”将自动推导foo为int类型）惊奇不已的时候，动态语言的开发者早已习以为常了。&lt;/p&gt;
&lt;p&gt;但天下没有白吃的午餐，变量使用起来越方便，背后的原理就越复杂，你以为你已经能将变量运用自如，但其实你只是个会开车的普通司机，你并不懂车。而你若想要成为PHP世界的专业级赛车手，赛车的每个零部件到组装到核心引擎的运转，你都必须了如指掌。&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="zval" scheme="http://www.twosee.cn/tags/zval/"/>
    
  </entry>
  
  <entry>
    <title>9102记我刚刚结束的平平无奇的大学生活</title>
    <link href="http://www.twosee.cn/2019/06/28/my-college-life/"/>
    <id>http://www.twosee.cn/2019/06/28/my-college-life/</id>
    <published>2019-06-28T10:06:06.000Z</published>
    <updated>2020-07-26T19:09:13.107Z</updated>
    
    <content type="html"><![CDATA[<p>大学四年，出于兴趣和热爱，我大概经历了以下这些事情：</p><p>知乎带图链接：<a href="https://zhuanlan.zhihu.com/p/71304826" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71304826</a></p><a id="more"></a><h4 id="2015年"><a href="#2015年" class="headerlink" title="2015年"></a>2015年</h4><ul><li>高考后成为外卖小哥，迷茫等待大学生涯</li><li>由于在入学某特长调研时如实填写了「毛笔字九级」和「漫画八级」，被诱拐进了学生会美术宣传部</li></ul><h4 id="2016年"><a href="#2016年" class="headerlink" title="2016年"></a>2016年</h4><ul><li>自学PS，成为了学院御用P图汪，承包了一年内学院所有的海报、公众号图片、GIF动画和活动PPT的制作</li><li>觉得做设计并不是自己的出路并持续怀疑人生…</li></ul><h4 id="2016年10月"><a href="#2016年10月" class="headerlink" title="2016年10月"></a>2016年10月</h4><ul><li>着手编写微信机器人(Custed雏形姬)，支持图灵聊天，网费充值，成绩查询，作业参考，网络报修，教务抢课，四六级代报代打印</li></ul><h4 id="2016年末"><a href="#2016年末" class="headerlink" title="2016年末"></a>2016年末</h4><ul><li>黑掉了校园一卡通充值系统(免登陆任意充值漏洞)，前往学校信息化中心报告，并籍此向老师和领导展示了我自认为牛逼哄哄的校园信息化计划草案，并立志从此招兵买马，实现我的创想</li><li>开始自学PHP/JS，并花一周时间重写了机器人，实现了Web版的<a href="https://m.cust.edu.cn" target="_blank" rel="noopener">Custed</a>的雏形</li></ul><h4 id="2016年12月"><a href="#2016年12月" class="headerlink" title="2016年12月"></a>2016年12月</h4><ul><li>短暂转型B站UP主，首次(也是最后一次)自制<a href="https://www.bilibili.com/video/av7495849" target="_blank" rel="noopener">AMV</a>，单日人气上动画分区TOP1 (当时B站流量没现在这么高啊)</li></ul><h4 id="2017年3月"><a href="#2017年3月" class="headerlink" title="2017年3月"></a>2017年3月</h4><ul><li>新学期万事俱备，APP上线公测，自制九图在本人的QQ空间进行了初步宣传获得3000点赞</li><li>自制海报奔走于三个校区张贴，宣传APP和招募成员</li></ul><h4 id="2017年4月"><a href="#2017年4月" class="headerlink" title="2017年4月"></a>2017年4月</h4><ul><li><a href="https://blog.tusi.site" target="_blank" rel="noopener">吐司工作室</a>成员招募成功并正式成立，开展会议成立小部门</li><li>工作室提早在校内封锁了勒索病毒相关端口，病毒在中国爆发后，长春理工大学未出现任何一例感染</li></ul><h4 id="2017年5-6月"><a href="#2017年5-6月" class="headerlink" title="2017年5~6月"></a>2017年5~6月</h4><ul><li>组织了<a href="https://m.cust.edu.cn/ed.cc" target="_blank" rel="noopener">校园一卡通大赛</a>和相关周边活动，由学生自主设计的最佳校园卡将在下一届投入使用</li></ul><h4 id="2017年9月"><a href="#2017年9月" class="headerlink" title="2017年9月"></a>2017年9月</h4><ul><li>新版<a href="https://app.cust.edu.cn" target="_blank" rel="noopener">Custed</a>雏形，<a href="https://ww1.sinaimg.cn/large/006DQdzWly1fn84iqbisvj30wo0oyacu.jpg" target="_blank" rel="noopener">技术架构升级</a>。</li></ul><h4 id="2017年10月"><a href="#2017年10月" class="headerlink" title="2017年10月"></a>2017年10月</h4><ul><li>QQ客服机器人吐司喵(Rocat)上线，智能应答学生群中的问题及提供服务器监控报警、组织消息群发、开会OTP签到等功能，至今仍在稳定运行</li></ul><h4 id="2017年下半年"><a href="#2017年下半年" class="headerlink" title="2017年下半年"></a>2017年下半年</h4><ul><li>开始接触并实践Linux下的运维操作，使用Docker部署服务和Docker-Compose编排服务，初步学习异步网络编程相关知识</li><li>入门Python并写了一些图片爬虫和学校题库数据整理脚本，用于题库APP方便学生背题</li><li>使用Python+Flask-SocketIO+requests写了一个基于WebSocket的QQ空间自动点赞机器人服务</li></ul><h4 id="2017年12月"><a href="#2017年12月" class="headerlink" title="2017年12月"></a>2017年12月</h4><ul><li>全国高校安全挑战赛决赛东北区第六</li></ul><h4 id="2018年前半年"><a href="#2018年前半年" class="headerlink" title="2018年前半年"></a>2018年前半年</h4><ul><li>学校领导采购smart-bi系统时，当场黑入对方公司系统后台，后提交漏洞盒子获高危评分</li><li>参加某全国大赛时和工作室小伙伴通过后台验证、文件上传漏洞、tty反射、Linux脏牛漏洞拿到了其服务器root权限，后上报修复</li></ul><h4 id="2018年3月"><a href="#2018年3月" class="headerlink" title="2018年3月"></a>2018年3月</h4><ul><li>尝试入门C语言并开始学习Linux下的高性能网络编程</li></ul><h4 id="2018年4月"><a href="#2018年4月" class="headerlink" title="2018年4月"></a>2018年4月</h4><ul><li>创建<a href="https://github.com/swlib" target="_blank" rel="noopener">Swlib</a>(Swoole人性化组件库)和后来社区的流行项目<a href="https://github.com/swlib/saber" target="_blank" rel="noopener">Saber</a></li><li>对社区知名开源项目<a href="https://github.com/swoft-cloud/swoft" target="_blank" rel="noopener">Swoft</a>和<a href="https://github.com/easy-swoole/easyswoole" target="_blank" rel="noopener">EasySwoole</a>贡献代码</li></ul><h4 id="2018年5月"><a href="#2018年5月" class="headerlink" title="2018年5月"></a>2018年5月</h4><ul><li>成为<a href="https://github.com/swoole/swoole-src" target="_blank" rel="noopener">Swoole</a>的Contributor</li></ul><h4 id="2018年6月"><a href="#2018年6月" class="headerlink" title="2018年6月"></a>2018年6月</h4><ul><li>优化代码，助力Swoole登上全球权威的Web项目性能跑分排行榜(<a href="https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=fortune" target="_blank" rel="noopener">TechEmpower</a>)第四，MySQL项第一</li></ul><h4 id="2018年7月"><a href="#2018年7月" class="headerlink" title="2018年7月"></a>2018年7月</h4><ul><li><p>受邀成为<a href="https://github.com/swoole/swoole-src" target="_blank" rel="noopener">Swoole</a>开发组成员</p></li><li><p>受邀在<a href="http://www.swoole-cloud.com/" target="_blank" rel="noopener">上海识沃网络科技有限公司</a>实习，开源事业为主，参与了商业项目的一些边角工作</p></li></ul><h4 id="2018年10月"><a href="#2018年10月" class="headerlink" title="2018年10月"></a>2018年10月</h4><ul><li>成为<a href="https://github.com/php/php-src" target="_blank" rel="noopener">PHP</a>的Contributor，多次修复ZendVM的BUG和做出一些优化</li><li>发布基于Swoole协程编写的的<a href="https://github.com/swoole/grpc" target="_blank" rel="noopener">Grpc/Etcd</a>客户端</li></ul><h4 id="2018年末-2019年初"><a href="#2018年末-2019年初" class="headerlink" title="2018年末~2019年初"></a>2018年末~2019年初</h4><ul><li>对<a href="https://github.com/swoole/swoole-src" target="_blank" rel="noopener">Swoole</a>整体进行了大量优化及重构，推进了协程特性的发展，遂成为项目Owner之一</li></ul><h4 id="2019年4月"><a href="#2019年4月" class="headerlink" title="2019年4月"></a>2019年4月</h4><ul><li>进入<a href="https://www.100tal.com/" target="_blank" rel="noopener">北京好未来学而思</a>实习，并就Swoole进行了一系列技术分享</li></ul><h4 id="2019年6月"><a href="#2019年6月" class="headerlink" title="2019年6月"></a>2019年6月</h4><ul><li>回校，体验珍惜也枉然，不出意外的离别，然后离别</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大学四年，出于兴趣和热爱，我大概经历了以下这些事情：&lt;/p&gt;
&lt;p&gt;知乎带图链接：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71304826&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/71304826&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="大学" scheme="http://www.twosee.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>PHP内核浅析: zend_read_property在键值不存在的时候究竟返回了什么?</title>
    <link href="http://www.twosee.cn/2018/09/23/what-are-zend-read-property-doing/"/>
    <id>http://www.twosee.cn/2018/09/23/what-are-zend-read-property-doing/</id>
    <published>2018-09-23T13:06:26.000Z</published>
    <updated>2020-07-17T10:28:24.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020更新：扩展对象使用“属性”来存储东西不是一个好的行为，我们可能需要花费很大代价来阻止来自PHP用户的破坏，至于更好的存储方法，我会在未来的文章中讲到</p></blockquote><p><code>zend_read_property</code>返回了什么, 其实我从前也未深究, 它的返回值类型是一个<code>zval *</code>, 所以很理所当然的, 大家都会认为如果获取了一个不存在的属性, 它的返回值就是<code>NULL</code>.</p><p>比如<code>zend_hash_str_find</code>这个API, 它会从<code>HashTable</code>里寻找对应的bucket, 然后获取它的值, 如果这个值不存在, 就返回NULL.</p><p>而且我们清楚, 不管是<code>array</code>, 还是<code>object</code>的<code>properties</code>, 都是用<code>HashTable</code>来存储的, 那么不存在的时候返回<code>NULL</code>, 也是理所当然.</p><p>这里还要注意一点, 我所指的不存在, 是在<code>HashTable</code>里没有这个bucket, 举个例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$foo = [<span class="string">'bar'</span> =&gt; <span class="keyword">null</span>];</span><br><span class="line">var_dump(<span class="keyword">isset</span>($foo[<span class="string">'bar'</span>])); <span class="comment">// false</span></span><br><span class="line">var_dump(array_key_exists(<span class="string">'bar'</span>, $foo)); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">unset</span>($foo[<span class="string">'bar'</span>]);</span><br><span class="line">var_dump(array_key_exists(<span class="string">'bar'</span>, $foo)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这样可以很清楚的发现区别了, 在置一个键为<code>null</code>的时候, 实际上是在这个<code>bucket</code>上放了一个<code>type = null</code>的<code>zval</code>,  而当使用<code>unset</code>的时候, 才是真正的把这个<code>bucket</code>从<code>HashTable</code>上删去了, 也就是说这个键和存储键值的容器都不存在了. 所以<code>unset</code>真是个很暴力的连根拔除的操作.</p><p><code>unset</code>的开销会比赋值<code>null</code>更大, 因为它删去属性的同时, 可能会触发数组结构重置, 这个问题在用<code>SplQueue</code>和<code>array_push/pop</code>对比的时候显而易见.</p><a id="more"></a><h3 id="错误案例"><a href="#错误案例" class="headerlink" title="错误案例"></a>错误案例</h3><p>出于安全性考虑, 我曾经写过一个函数, 犯了愚蠢的错误:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> sw_inline zval* <span class="title">sw_zend_read_property_array</span><span class="params">(zend_class_entry *class_ptr, zval *obj, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zval rv, *property = zend_read_property(class_ptr, obj, s, len, silent, &amp;rv);</span><br><span class="line">    zend_uchar ztype = Z_TYPE_P(property);</span><br><span class="line">    <span class="keyword">if</span> (ztype != IS_ARRAY)</span><br><span class="line">    &#123;</span><br><span class="line">        zval temp_array;</span><br><span class="line">        array_init(&amp;temp_array);</span><br><span class="line">        zend_update_property(class_ptr, obj, s, len, &amp;temp_array TSRMLS_CC);</span><br><span class="line">        zval_ptr_dtor(&amp;temp_array);</span><br><span class="line">        <span class="comment">// NOTICE: if user unset the property, this pointer will be changed</span></span><br><span class="line">        <span class="comment">// some objects such as `swoole_http2_request` always be writable</span></span><br><span class="line">        <span class="keyword">if</span> (ztype == IS_UNDEF)</span><br><span class="line">        &#123;</span><br><span class="line">            property = zend_read_property(class_ptr, obj, s, len, silent, &amp;rv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个函数是用来安全地从一个object上获取一个array类型的属性, 在该属性不为array类型的时候, 更新为一个空数组, 然后再返回该属性的指针.</p><p>因为在底层常常会有类似这样的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zval *property = zend_read_property(ce, object, ZEND_STRL(<span class="string">"headers"</span>), <span class="number">1</span>);</span><br><span class="line">add_assoc_string(property, <span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure><p>一般属性都是被定义好的且初始化好的, 但难免有开发者会在PHP代码中改变它, 比如我自己就这么做了, 在某个清理方法中把<code>$request-&gt;headers = null</code>, 然后底层读取出了一个null的zval, 调用<code>add_assoc_string</code>的时候, 把这个属性当做了array, 就产生了coredump. 所以弄一个包含检查的内联函数来安全的获取指定类型的属性, 还是很有必要的.</p><p>在这个函数中, 我为了节省一次<code>zend_read_property</code>的开销, 判断了前一次读出属性的类型, 在我的潜意识里, 获取到了标记为UNDEF的zval, 前后指针会变化, 所以我判断了它是IS_UNDEF的时候才重新读一次属性. 因为已存在的属性, 就算更新它的值, 它的指针(即bucket的位置)也不会改变.</p><p>我常常是一个实战派, 当时我用LLDB跟踪验证了一下, 不论在何种情况, 前后指针都没有变化, 这是一个安全的方式, 于是我就放心的这么写了.</p><p>后来, 我接二连三在书写极端单元测试的时候遇到问题, 所谓极端单元测试, 是指我时不时的<code>unset</code>掉测试用例里的某个本应该为null的属性, 看看会不会出现问题, 结果产生了一系列coredump.</p><p>后来我发现了, 是因为我写操作了获取到的null zval, 产生了内存错误, 但是为什么不能操作它呢?</p><p>这时候我终于知道去看一眼PHP源码了…马上翻到<code>zend_std_read_property</code>这个标准的handler看一眼:</p><p>入眼就能看到一个:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Z_TYPE_P(rv) != IS_UNDEF) &#123;</span><br><span class="line">    retval = rv;</span><br><span class="line">    <span class="keyword">if</span> (!Z_ISREF_P(rv) &amp;&amp;</span><br><span class="line">        (type == BP_VAR_W || type == BP_VAR_RW  || type == BP_VAR_UNSET)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNEXPECTED(Z_TYPE_P(rv) != IS_OBJECT)) &#123;</span><br><span class="line">            zend_error(E_NOTICE, <span class="string">"Indirect modification of overloaded property %s::$%s has no effect"</span>, ZSTR_VAL(zobj-&gt;ce-&gt;name), ZSTR_VAL(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    retval = &amp;EG(uninitialized_zval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>潜意识是没错了…在property的unset操作中, unset一个属性, 应该是有可能会将它标记为UNDEF的, 因为一般一个类的实例对象的HashTable是不变动的, unset其实是破坏了其结构的, 标记为UNDEF应该是一种优化.</p><p>但是zend_std_read_property对其进行了包装了, 返回了一个<code>EG(uninitialized_zval)</code>的指针, 这是个什么东西?</p><p>这其实就是个<code>type = null</code>的zval, 比较秀的是, 它是一个挂在<code>executor_globals</code>上的全局量, 便于随时取用作为返回值, 它被设计为只读的, 所以我们的千万不能操作它…</p><p>比如mysqli扩展中就用到了它来判断, 规避了非法的写操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value != &amp;EG(uninitialized_zval)) &#123;</span><br><span class="line">    convert_to_boolean(value);</span><br><span class="line">    ret = Z_TYPE_P(value) == IS_TRUE ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们应该纠正为(注释是美德)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NOTICE: if user unset the property, zend_read_property will return uninitialized_zval instead of NULL pointer</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(property == &amp;EG(uninitialized_zval)))</span><br><span class="line">&#123;</span><br><span class="line">    property = zend_read_property(class_ptr, obj, s, len, silent, &amp;rv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个包装是很好的, 保证了API返回的一定是一个<strong>可读的zval</strong>, 但是PHP底层的文档实在是太少了, 尤其是中国的开发者, 很难在网上找到任何有价值的东西, 需要一定的源码阅读能力和耐心才行, 否则经常会遇上这种非直觉的设计, 就是地狱难度的开发.</p><blockquote><p>该API起码自PHP7起就一直如此设计, 使用<code>git blame</code>来查看API变动也是良好的习惯之一, 因为ZendVM经常会有一些你意想不到的API改动…</p><p><a href="https://github.com/php/php-src/blob/2bf8f29d16e6875e65eaa538a9740aac31ce650a/Zend/zend_object_handlers.c" target="_blank" rel="noopener">https://github.com/php/php-src/blob/2bf8f29d16e6875e65eaa538a9740aac31ce650a/Zend/zend_object_handlers.c</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2020更新：扩展对象使用“属性”来存储东西不是一个好的行为，我们可能需要花费很大代价来阻止来自PHP用户的破坏，至于更好的存储方法，我会在未来的文章中讲到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;zend_read_property&lt;/code&gt;返回了什么, 其实我从前也未深究, 它的返回值类型是一个&lt;code&gt;zval *&lt;/code&gt;, 所以很理所当然的, 大家都会认为如果获取了一个不存在的属性, 它的返回值就是&lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;比如&lt;code&gt;zend_hash_str_find&lt;/code&gt;这个API, 它会从&lt;code&gt;HashTable&lt;/code&gt;里寻找对应的bucket, 然后获取它的值, 如果这个值不存在, 就返回NULL.&lt;/p&gt;
&lt;p&gt;而且我们清楚, 不管是&lt;code&gt;array&lt;/code&gt;, 还是&lt;code&gt;object&lt;/code&gt;的&lt;code&gt;properties&lt;/code&gt;, 都是用&lt;code&gt;HashTable&lt;/code&gt;来存储的, 那么不存在的时候返回&lt;code&gt;NULL&lt;/code&gt;, 也是理所当然.&lt;/p&gt;
&lt;p&gt;这里还要注意一点, 我所指的不存在, 是在&lt;code&gt;HashTable&lt;/code&gt;里没有这个bucket, 举个例子:&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$foo = [&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var_dump(&lt;span class=&quot;keyword&quot;&gt;isset&lt;/span&gt;($foo[&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;])); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var_dump(array_key_exists(&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;, $foo)); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unset&lt;/span&gt;($foo[&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var_dump(array_key_exists(&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;, $foo)); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样可以很清楚的发现区别了, 在置一个键为&lt;code&gt;null&lt;/code&gt;的时候, 实际上是在这个&lt;code&gt;bucket&lt;/code&gt;上放了一个&lt;code&gt;type = null&lt;/code&gt;的&lt;code&gt;zval&lt;/code&gt;,  而当使用&lt;code&gt;unset&lt;/code&gt;的时候, 才是真正的把这个&lt;code&gt;bucket&lt;/code&gt;从&lt;code&gt;HashTable&lt;/code&gt;上删去了, 也就是说这个键和存储键值的容器都不存在了. 所以&lt;code&gt;unset&lt;/code&gt;真是个很暴力的连根拔除的操作.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unset&lt;/code&gt;的开销会比赋值&lt;code&gt;null&lt;/code&gt;更大, 因为它删去属性的同时, 可能会触发数组结构重置, 这个问题在用&lt;code&gt;SplQueue&lt;/code&gt;和&lt;code&gt;array_push/pop&lt;/code&gt;对比的时候显而易见.&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="zend" scheme="http://www.twosee.cn/tags/zend/"/>
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>用0.04秒看出大佬的网络编程基本功素养</title>
    <link href="http://www.twosee.cn/2018/09/16/tcp-nodelay/"/>
    <id>http://www.twosee.cn/2018/09/16/tcp-nodelay/</id>
    <published>2018-09-16T15:32:08.000Z</published>
    <updated>2018-09-19T07:30:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>  事情是这样的, 最近在做Swoole的Websocket的底层代码优化, 和编写更多的单元测试来保证代码正确和功能的稳定性, 写了很多高质量的”混沌”测试, 好吧, 其实并不是那么混沌, 只是这个词眼看起来很帅.<br>以往的unit tests更像是一些带着assert的examples, 加之phpt的测试风格, 顶多再来个EXPECT(F/REGEX)的预期输出对比, 只能测试出这个功能能否跑通, 并没有覆盖到功能的健壮性.而每当底层出现BUG接着我们很快就发现了原因时, 都会感叹单元测试不够全面和完善.<br>  所以在新写的测试中, 我尽量引入随机数据和一定量的并发压力来简单的模拟各种情况, 在自动化的单元测试中这样的做法已经是权衡了测试敏捷和健全的最优解了, 比如以下这个名为<code>websocket-fin</code>的测试:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$count = <span class="number">0</span>;</span><br><span class="line">$pm = <span class="keyword">new</span> ProcessManager;</span><br><span class="line">$pm-&gt;parentFunc = <span class="function"><span class="keyword">function</span> <span class="params">(int $pid)</span> <span class="title">use</span> <span class="params">($pm, &amp;$count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($c = MAX_CONCURRENCY; $c--;) &#123;</span><br><span class="line">        go(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($pm, &amp;$count)</span> </span>&#123;</span><br><span class="line">            $cli = <span class="keyword">new</span> \Swoole\Coroutine\Http\Client(<span class="string">'127.0.0.1'</span>, $pm-&gt;getFreePort());</span><br><span class="line">            $cli-&gt;set([<span class="string">'timeout'</span> =&gt; <span class="number">5</span>]);</span><br><span class="line">            $ret = $cli-&gt;upgrade(<span class="string">'/'</span>);</span><br><span class="line">            assert($ret);</span><br><span class="line">            $rand_list = [];</span><br><span class="line">            $times = MAX_REQUESTS;</span><br><span class="line">            <span class="keyword">for</span> ($n = $times; $n--;) &#123;</span><br><span class="line">                $rand = openssl_random_pseudo_bytes(mt_rand(<span class="number">0</span>, <span class="number">1280</span>));</span><br><span class="line">                $rand_list[] = $rand;</span><br><span class="line">                $opcode = $n === $times - <span class="number">1</span> ? WEBSOCKET_OPCODE_TEXT : WEBSOCKET_OPCODE_CONTINUATION;</span><br><span class="line">                $finish = $n === <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (mt_rand(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    $frame = <span class="keyword">new</span> swoole_websocket_frame;</span><br><span class="line">                    $frame-&gt;opcode = $opcode;</span><br><span class="line">                    $frame-&gt;data = $rand;</span><br><span class="line">                    $frame-&gt;finish = $finish;</span><br><span class="line">                    $ret = $cli-&gt;push($frame);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    $ret = $cli-&gt;push($rand, $opcode, $finish);</span><br><span class="line">                &#125;</span><br><span class="line">                assert($ret);</span><br><span class="line">            &#125;</span><br><span class="line">            $frame = $cli-&gt;recv();</span><br><span class="line">            <span class="keyword">if</span> (assert($frame-&gt;data === implode(<span class="string">''</span>, $rand_list))) &#123;</span><br><span class="line">                $count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    swoole_event_wait();</span><br><span class="line">    assert($count === MAX_CONCURRENCY);</span><br><span class="line">    $pm-&gt;kill();</span><br><span class="line">&#125;;</span><br><span class="line">$pm-&gt;childFunc = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($pm)</span> </span>&#123;</span><br><span class="line">    $serv = <span class="keyword">new</span> swoole_websocket_server(<span class="string">'127.0.0.1'</span>, $pm-&gt;getFreePort(), mt_rand(<span class="number">0</span>, <span class="number">1</span>) ? SWOOLE_BASE : SWOOLE_PROCESS);</span><br><span class="line">    $serv-&gt;set([</span><br><span class="line">        <span class="string">'log_file'</span> =&gt; <span class="string">'/dev/null'</span></span><br><span class="line">    ]);</span><br><span class="line">    $serv-&gt;on(<span class="string">'WorkerStart'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($pm)</span> </span>&#123;</span><br><span class="line">        $pm-&gt;wakeup();</span><br><span class="line">    &#125;);</span><br><span class="line">    $serv-&gt;on(<span class="string">'Message'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(swoole_websocket_server $serv, swoole_websocket_frame $frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mt_rand(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            $serv-&gt;push($frame-&gt;fd, $frame);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $serv-&gt;push($frame-&gt;fd, $frame-&gt;data, $frame-&gt;opcode, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $serv-&gt;start();</span><br><span class="line">&#125;;</span><br><span class="line">$pm-&gt;childFirst();</span><br><span class="line">$pm-&gt;run();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><p>  Swoole中涉及网络服务的测试模型一般都长这样, 一个PHP写的简易好用的<code>ProcessManager</code>来管理进程, 子进程(childFunc)一般为服务, 父进程(parentFunc)一般为客户端, 来测试收发处理是否正确.</p><p>  首先子进程会先运行(<code>childFirst</code>), 服务创建成功后, 会进入<code>onWorkerStart</code>回调, 此时服务已经能进行请求处理, 通过<code>wakeup</code>唤起父进程,父进程会顺序执行, 创建多个协程, 在<code>swoole_event_wait</code>处进入事件循环, 待所有协程运行完毕后, 断言执行成功次数是否正确, 然后kill掉进程退出测试.</p><p>  在这里我们并发了<code>MAX_CONCURRENCY</code>个数的协程来请求服务器(相当于<code>ab测试</code>的<code>-c</code>参数), 这里使用<code>MAX_CONCURRENCY</code>常量的原因是<code>TravisCI</code>(线上自动化集成测试)的配置并不是那么好, 不一定能承载住稍大的并发, 常量的值可以在不同环境下有所区别, 而积极使用常量也能让一个程序的可读性, 可移植性大大提升.</p><p>  每个协程里都创建一个HTTP客户端(连接), 连接建立后, 通过<code>upgrade</code>升级到websocket协议, 执行<code>MAX_REQUESTS</code>次(相当于<code>ab测试</code>的<code>-n</code>参数)的请求逻辑, 每一次都会通过<code>openssl_random_pseudo_bytes</code>来生成一串0~1280字节的随机字符串, 添加到<code>$rand_list</code>的同时向服务器发送.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$opcode = $n === $times - <span class="number">1</span> ? WEBSOCKET_OPCODE_TEXT : WEBSOCKET_OPCODE_CONTINUATION;</span><br><span class="line">$finish = $n === <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  这两句代码的意思是, 在websocket中使用<code>分段发送帧</code>的时候, 第一帧的opcode是确切的帧类型(这里是TEXT), fin为0, 代表帧未结束, 后续帧的opcode都是<code>WEBSOCKET_OPCODE_CONTINUATION</code>, 表示这是一个连续帧, 直到最后一帧(n==0循环结束)fin变为1, 代表帧结束.</p><p>  这个连续帧最多有<code>MAX_REQUESTS</code>帧, 值一般为100, 1280字节*100次也就是最大128K左右, 这个测试量也就是稀松平常, 对于swoole来说并不算是有什么压力, 称不上压力测试, 只是通过随机数据来尽可能保证各种情况下的可用性.</p><h2 id="蜜汁耗时"><a href="#蜜汁耗时" class="headerlink" title="蜜汁耗时"></a>蜜汁耗时</h2><p>  而恰好我又在最近为自动化测试加上了一个耗时统计选项, 很奇怪的结果出现了, fin测试居然耗时超过20s, 这个问题在我的MacOS下并不存在, 但是却在Ubuntu复现了.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fveqbea7h9j31fs0h4qaw.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>  同样出现问题的还有greeter测试, 它们都有一个共同的问题, 就是它们使用了<strong>websocket通信单个连接多次发包.</strong></p><p>  BUG能在Ubuntu下复现是个好事, 因为MacOS除了<code>LLDB</code>根本没有好用的调试工具, <code>valgrind</code>不可用, 而<code>strace</code>的替代品<code>dtruss</code>也不甚好用, 在Ubuntu下使用<code>strace</code>跟踪, 很快就能看到以下日志:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fveu8j5bqcj31j616e1kx.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>  如果是使用标准输出跟踪可以看到打印的信息非常正常, 由于数据量大屏幕会不断滚动, 但并没有出现卡顿, 数据传输也很均匀, 可以看到有很多<code>getpid</code>的系统调用, 第一反应是是不是这个的问题, 稍微确认一下就能发现这是<code>openssl_random_pseudo_bytes</code>的系统调用, 并没有什么关系.</p><h2 id="前辈经验"><a href="#前辈经验" class="headerlink" title="前辈经验"></a>前辈经验</h2><p>  量大就慢是不可能的, 在MacOS下完成这个脚本只需眨眼之间, 且没有任何错误, 苦思了半天也不得解, 只能求助rango, rango刚开始看思路和我差不多, 也是先看到了大量的<code>getpid</code>, 稍加思索马上就排除了这个, 在标准输出中跟踪也发现非常正常, 然后觉得是不是数据量太大了, 但是稍加确认又马上排除.</p><p>  很快, 他就注意到了epoll_wait的等待时间格外的长, 虽然我也注意到了, 但我只注意到了格外的长, 并没有留意长出来的时间是多少, 数据是不间断连续发送的, 却有<strong>40ms</strong>的延迟, 这对于本机的两端互发数据来说是一个很大的值了.</p><p>  “0.04s, 不会是那个吧”, 说罢rango马上<strong>在配置项加上了一个<code>open_tcp_nodelay =&gt; false</code>, 再跑一次测试, 问题解决…</strong></p><p>  这就是名震江湖的<strong>调参术</strong>吗…像以前用windows的时候, 经常能看到一个水文, <strong><code>一招让你电脑网速提升20%</code></strong>  , 大概是通过配置关闭了TCP的<strong>慢启动</strong>, 让测速结果更加好看, 实际上可能并没有什么效果, 反而让这个优秀的设计在相关网络场景下失去效用, 造成<strong>拥塞</strong>.</p><p>  但是这个东西完全是关于<strong><code>基本功</code>和<code>经验</code></strong>, 我压根不知道这个东西, 看破脑袋也看不出这个关键的40ms, 而我没有相关的经验, 就算有相关的网络编程知识也一时很难联系起来.</p><p>##TCP_NOLAY 与 Nagle合并算法</p><p>  开启  <code>TCP_NOLAY</code>实际是关闭<code>Nagle合并算法</code>, 这个算法在网上的讲解有很多, 而且原理也非常简单, 写的肯定比我好多了, 如维基上的伪码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> there is <span class="keyword">new</span> data to send</span><br><span class="line">  <span class="keyword">if</span> the window <span class="built_in">size</span> &gt;= MSS <span class="keyword">and</span> <span class="built_in">available</span> data is &gt;= MSS</span><br><span class="line">    send complete MSS segment now</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> there is unconfirmed data still in the pipe</span><br><span class="line">      enqueue data in the <span class="built_in">buffer</span> until an acknowledge is received</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      send data immediately</span><br><span class="line">    <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line">  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="built_in">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure><p> 而<a href="https://www.zhihu.com/question/42308970/answer/246334766" target="_blank" rel="noopener">Nagle算法是时代的产物，因为当时网络带宽有限</a>, 于是我就把Swoole的<code>TCP_NODELAY</code>改为默认开启了, 不要急, <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#tcp_nodelay" target="_blank" rel="noopener">Nginx-tcp_nodelay</a>和php_stream等也是这么做的, 大家都有自己的缓冲区, 无需立即发送的小数据包是不会马上发出去的, 例如最重要的HTTP, 它是<code>读-写-读-写</code>模式的, 数据都是等请求<code>end</code>了之后才会一并发出(除非使用了chunk), 也就是说, 如果数据确实发出了, 那么它就有发出的必要性(哪怕它是个小数据包), 开发者希望它总是保持低延迟的, 而不是动不动就出来40ms, 若想要底层防止拥塞, 那么届时再手动开启<code>Nagle合并算法</code>.</p><p>  在我写完以上内容后, 我搜了一下, 发现这个问题有很多让我哭笑的标题:</p><ul><li><a href="https://blog.csdn.net/zheng0518/article/details/78561246" target="_blank" rel="noopener">神秘的40毫秒延迟与 TCP_NODELAY</a></li><li><a href="https://blog.csdn.net/historyasamirror/article/details/6122284" target="_blank" rel="noopener">写socket的“灵异事件”</a></li><li><p><a href="https://cloud.tencent.com/developer/article/1004431" target="_blank" rel="noopener">再说TCP神奇的40ms</a></p><p>好吧, 肯来很多前人都被这个神奇的40ms困扰过, 说明写个博客还是很能造福后人的.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;  事情是这样的, 最近在做Swoole的Websocket的底层代码优化, 和编写更多的单元测试来保证代码正确和功能的稳定性, 写了很多高质量的”混沌”测试, 好吧, 其实并不是那么混沌, 只是这个词眼看起来很帅.&lt;br&gt;以往的unit tests更像是一些带着assert的examples, 加之phpt的测试风格, 顶多再来个EXPECT(F/REGEX)的预期输出对比, 只能测试出这个功能能否跑通, 并没有覆盖到功能的健壮性.而每当底层出现BUG接着我们很快就发现了原因时, 都会感叹单元测试不够全面和完善.&lt;br&gt;  所以在新写的测试中, 我尽量引入随机数据和一定量的并发压力来简单的模拟各种情况, 在自动化的单元测试中这样的做法已经是权衡了测试敏捷和健全的最优解了, 比如以下这个名为&lt;code&gt;websocket-fin&lt;/code&gt;的测试:&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProcessManager;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm-&amp;gt;parentFunc = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(int $pid)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($pm, &amp;amp;$count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ($c = MAX_CONCURRENCY; $c--;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        go(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($pm, &amp;amp;$count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $cli = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; \Swoole\Coroutine\Http\Client(&lt;span class=&quot;string&quot;&gt;&#39;127.0.0.1&#39;&lt;/span&gt;, $pm-&amp;gt;getFreePort());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $cli-&amp;gt;set([&lt;span class=&quot;string&quot;&gt;&#39;timeout&#39;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $ret = $cli-&amp;gt;upgrade(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            assert($ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $rand_list = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $times = MAX_REQUESTS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ($n = $times; $n--;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $rand = openssl_random_pseudo_bytes(mt_rand(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1280&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $rand_list[] = $rand;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $opcode = $n === $times - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ? WEBSOCKET_OPCODE_TEXT : WEBSOCKET_OPCODE_CONTINUATION;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $finish = $n === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mt_rand(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $frame = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; swoole_websocket_frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $frame-&amp;gt;opcode = $opcode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $frame-&amp;gt;data = $rand;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $frame-&amp;gt;finish = $finish;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $ret = $cli-&amp;gt;push($frame);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $ret = $cli-&amp;gt;push($rand, $opcode, $finish);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                assert($ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $frame = $cli-&amp;gt;recv();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (assert($frame-&amp;gt;data === implode(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, $rand_list))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    swoole_event_wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert($count === MAX_CONCURRENCY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $pm-&amp;gt;kill();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm-&amp;gt;childFunc = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($pm)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; swoole_websocket_server(&lt;span class=&quot;string&quot;&gt;&#39;127.0.0.1&#39;&lt;/span&gt;, $pm-&amp;gt;getFreePort(), mt_rand(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) ? SWOOLE_BASE : SWOOLE_PROCESS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv-&amp;gt;set([&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;log_file&#39;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&#39;/dev/null&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv-&amp;gt;on(&lt;span class=&quot;string&quot;&gt;&#39;WorkerStart&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($pm)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $pm-&amp;gt;wakeup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv-&amp;gt;on(&lt;span class=&quot;string&quot;&gt;&#39;Message&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(swoole_websocket_server $serv, swoole_websocket_frame $frame)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mt_rand(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $serv-&amp;gt;push($frame-&amp;gt;fd, $frame);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $serv-&amp;gt;push($frame-&amp;gt;fd, $frame-&amp;gt;data, $frame-&amp;gt;opcode, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv-&amp;gt;start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm-&amp;gt;childFirst();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm-&amp;gt;run();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
      <category term="tcp&quot;" scheme="http://www.twosee.cn/tags/tcp/"/>
    
      <category term="nodelay" scheme="http://www.twosee.cn/tags/nodelay/"/>
    
      <category term="nagle" scheme="http://www.twosee.cn/tags/nagle/"/>
    
  </entry>
  
  <entry>
    <title>自定义zend_object的结构体的hack技巧</title>
    <link href="http://www.twosee.cn/2018/07/17/custom-zend-object-hack-way/"/>
    <id>http://www.twosee.cn/2018/07/17/custom-zend-object-hack-way/</id>
    <published>2018-07-16T16:08:00.000Z</published>
    <updated>2018-07-16T16:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究这个主要是为了解决<code>swoole-socket</code>模块的一个coredump的bug, 之前swoole采用了<code>swoole_get/set_object</code>等做法来存取对应的对象, 只有socket模块使用了魔改zend_object的方法, 但是PHP7里用了比较hack的结构体技巧, 导致了一系列问题, 想魔改zend_object, 需要一番操作, 中文文档很难找到用法的, 都是一笔带过, 需要去看英文文档.</p><p>虽然只有一次提交, 但其实改了不下几十遍, 在此记录一下:</p><blockquote><p>第一个参考文章: <a href="https://segmentfault.com/a/1190000004173452" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004173452</a></p></blockquote><p>Swoole在<code>socket coro</code>中使用了别的模块没有用到的自定义zend_object属性的技巧, 但是PHP7中它需要做额外的处理, 导致了一些问题.</p><h3 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h3><p>因为 <code>zend_object</code> 在存储属性表时用了结构体 hack 的技巧，<code>zend_object</code> 尾部存储的 PHP 属性会覆盖掉后续添加进去的内部成员。所以 PHP7 的实现中必须把自己添加的成员添加到标准对象结构的前面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct custom_object &#123;</span><br><span class="line">    uint32_t something;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    zend_object std;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过这样也就意味着现在无法直接在 zend_object<em> 和 struct custom_object</em> 进行简单的转换了，因为两者都一个偏移分割开了。所以这个偏移量就需要被存储在对象 handler 表中的第一个元素中，这样在编译时通过 offsetof() 宏就能确定具体的偏移值</p><a id="more"></a><hr><p>但是现在仍不知道具体的操作方式, 只能去搜官网的英文文档等</p><p>官网有一篇从PHP5升级到PHPNG的文章中提到了这个坑</p><blockquote><p>ref: <a href="https://wiki.php.net/phpng-upgrading" target="_blank" rel="noopener">https://wiki.php.net/phpng-upgrading</a></p></blockquote><p>Custom Objects 一节:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zend_object * <span class="title">custom_object_new</span><span class="params">(zend_class_entry *ce TSRMLS_DC)</span> </span>&#123;</span><br><span class="line">     # Allocate sizeof(custom) + sizeof(properties table requirements)</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">custom_object</span> *<span class="title">intern</span> = <span class="title">ecalloc</span>(1, </span></span><br><span class="line"><span class="class">         <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">custom_object</span>) + </span></span><br><span class="line"><span class="class">         <span class="title">zend_object_properties_size</span>(<span class="title">ce</span>));</span></span><br><span class="line">     # Allocating:</span><br><span class="line">     <span class="meta"># struct custom_object &#123;</span></span><br><span class="line">     <span class="meta">#    void *custom_data;</span></span><br><span class="line">     #    zend_object <span class="built_in">std</span>;</span><br><span class="line">     # &#125;</span><br><span class="line">     <span class="meta"># zval[ce-&gt;default_properties_count-1]</span></span><br><span class="line">     zend_object_std_init(&amp;intern-&gt;<span class="built_in">std</span>, ce TSRMLS_CC);</span><br><span class="line">     ...</span><br><span class="line">     custom_object_handlers.offset = XtOffsetOf(struct custom_obj, <span class="built_in">std</span>);</span><br><span class="line">     custom_object_handlers.free_obj = custom_free_storage;</span><br><span class="line"> </span><br><span class="line">     intern-&gt;<span class="built_in">std</span>.handlers = custom_object_handlers;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> &amp;intern-&gt;<span class="built_in">std</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的是swoole中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">swoole_socket_coro_class_entry_ptr-&gt;create_object = swoole_socket_coro_create;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> zend_object *<span class="title">swoole_socket_coro_create</span><span class="params">(zend_class_entry *ce TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    socket_coro *sock = ecalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(socket_coro) + zend_object_properties_size(ce));</span><br><span class="line">    <span class="comment">// 这里要给properties_size额外分配内存</span></span><br><span class="line">    zend_object_std_init(&amp;sock-&gt;<span class="built_in">std</span>, ce TSRMLS_CC);</span><br><span class="line">    object_properties_init(&amp;sock-&gt;<span class="built_in">std</span>, ce); <span class="comment">//这是坑2加的</span></span><br><span class="line">    sock-&gt;<span class="built_in">std</span>.handlers = &amp;swoole_socket_coro_handlers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;sock-&gt;<span class="built_in">std</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们得做一个方法和一个<strong><code>Z_SOCKET_CORO_OBJ_P</code></strong>宏来从zval或zend_object获取socket_coro</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> socket_coro * <span class="title">sw_socket_coro_fetch_object</span><span class="params">(zend_object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (socket_coro *) ((<span class="keyword">char</span> *) obj - XtOffsetOf(socket_coro, <span class="built_in">std</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_SOCKET_CORO_OBJ_P(zv) sw_socket_coro_fetch_object(Z_OBJ_P(zv));</span></span><br></pre></td></tr></table></figure><p>在方法里这么用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket_coro *sock = (socket_coro *) Z_SOCKET_CORO_OBJ_P(getThis());</span><br></pre></td></tr></table></figure><h3 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h3><p>但是这里又踩了个坑…使用自定义的create_object之后…对象属性并不会自己初始化</p><p>我发现之前的swoole socket coro压根没有errCode属性…</p><p>在zend_object里没有相关API, 好不容易又找到另一篇文章, 找到了API…</p><blockquote><p>ref: <a href="http://www.phpinternalsbook.com/classes_objects/custom_object_storage.html" target="_blank" rel="noopener">http://www.phpinternalsbook.com/classes_objects/custom_object_storage.html</a></p></blockquote><p>在Overriding create_object一节…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_properties_init(&amp;sock-&gt;<span class="built_in">std</span>, ce);</span><br></pre></td></tr></table></figure><h3 id="坑3"><a href="#坑3" class="headerlink" title="坑3"></a>坑3</h3><p>之前没用过socket组件, accept会返回一个socket coro对象, 以为修好了, server端又coredump了</p><p>因为: </p><p>在创建对象的时候，Zend并不会帮我们调用构造函数，需要我们自己显式的在object上调用__construct方法</p><p>或者做和__construct方法一样的事情</p><p>在onReadable事件里这样改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (conn &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    zend_object *client;</span><br><span class="line">    client = swoole_socket_coro_create(swoole_socket_coro_class_entry_ptr);</span><br><span class="line">    socket_coro *client_sock = (socket_coro *) sw_socket_coro_fetch_object(client);</span><br><span class="line">    ZVAL_OBJ(&amp;result, &amp;client_sock-&gt;<span class="built_in">std</span>);</span><br><span class="line">    client_sock-&gt;fd = conn;</span><br><span class="line">    client_sock-&gt;domain = sock-&gt;domain;</span><br><span class="line">    client_sock-&gt;object = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;研究这个主要是为了解决&lt;code&gt;swoole-socket&lt;/code&gt;模块的一个coredump的bug, 之前swoole采用了&lt;code&gt;swoole_get/set_object&lt;/code&gt;等做法来存取对应的对象, 只有socket模块使用了魔改zend_object的方法, 但是PHP7里用了比较hack的结构体技巧, 导致了一系列问题, 想魔改zend_object, 需要一番操作, 中文文档很难找到用法的, 都是一笔带过, 需要去看英文文档.&lt;/p&gt;
&lt;p&gt;虽然只有一次提交, 但其实改了不下几十遍, 在此记录一下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一个参考文章: &lt;a href=&quot;https://segmentfault.com/a/1190000004173452&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000004173452&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Swoole在&lt;code&gt;socket coro&lt;/code&gt;中使用了别的模块没有用到的自定义zend_object属性的技巧, 但是PHP7中它需要做额外的处理, 导致了一些问题.&lt;/p&gt;
&lt;h3 id=&quot;坑1&quot;&gt;&lt;a href=&quot;#坑1&quot; class=&quot;headerlink&quot; title=&quot;坑1&quot;&gt;&lt;/a&gt;坑1&lt;/h3&gt;&lt;p&gt;因为 &lt;code&gt;zend_object&lt;/code&gt; 在存储属性表时用了结构体 hack 的技巧，&lt;code&gt;zend_object&lt;/code&gt; 尾部存储的 PHP 属性会覆盖掉后续添加进去的内部成员。所以 PHP7 的实现中必须把自己添加的成员添加到标准对象结构的前面：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct custom_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint32_t something;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F;&amp;#x2F; ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    zend_object std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过这样也就意味着现在无法直接在 zend_object&lt;em&gt; 和 struct custom_object&lt;/em&gt; 进行简单的转换了，因为两者都一个偏移分割开了。所以这个偏移量就需要被存储在对象 handler 表中的第一个元素中，这样在编译时通过 offsetof() 宏就能确定具体的偏移值&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="zend" scheme="http://www.twosee.cn/tags/zend/"/>
    
  </entry>
  
  <entry>
    <title>在Swoole中实现MySQL存储过程</title>
    <link href="http://www.twosee.cn/2018/07/16/mysql-procedure-implementation-in-swoole/"/>
    <id>http://www.twosee.cn/2018/07/16/mysql-procedure-implementation-in-swoole/</id>
    <published>2018-07-16T15:59:58.000Z</published>
    <updated>2018-07-16T16:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>大概是在一个月前了…那时候刚开始给swoole contribute代码, 初生牛犊, 修了不少小bug, 最后某位仁兄贴了个issue说swoole的mysql-client搞不掂存储过程, 当时我想想, 存储过程这东西实在没什么用, 甚至在很多大公司开发手册上是禁止使用的(某里粑粑), 具体的 <a href="https://www.zhihu.com/question/57545650" target="_blank" rel="noopener"><strong>为什么不要使用存储过程</strong></a> 戳这里, 但是考虑到一个作为一个底层扩展, 各种用户都有, rango就给我分配了这个任务, 于是我就马上进行了一番研究.</p><p>其实内容当时在PR里都贴了, <a href="https://github.com/swoole/swoole-src/pull/1688" target="_blank" rel="noopener">https://github.com/swoole/swoole-src/pull/1688</a>, 现在在博客补个票</p><p>完整的MySQL存储过程支持</p><hr><p>做了以下几件事:</p><h2 id="fetch-mode"><a href="#fetch-mode" class="headerlink" title="fetch mode"></a>fetch mode</h2><p>一开始先想着和PDO一样给Swoole做一个fetch模式</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'fetch_mode'</span> =&gt; <span class="keyword">true</span>] <span class="comment">//连接配置里加入这个</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $db-&gt;prepare(<span class="string">'SELECT `id` FROM `userinfo` LIMIT 2'</span>);</span><br><span class="line">$stmt-&gt;execute(); <span class="comment">// true = success</span></span><br><span class="line">$stmt-&gt;fetch(); <span class="comment">// result-set array 1</span></span><br><span class="line">$stmt-&gt;fetch(); <span class="comment">// result-set array 2</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="分离client和statement"><a href="#分离client和statement" class="headerlink" title="分离client和statement"></a>分离client和statement</h2><p>加了一个 <code>MYSQL_RESPONSE_BUFFER</code> 宏, 处理了一些代码分离了client和statement的buffer</p><p>并给statement结构上也挂了一个result的zval指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    swString *<span class="built_in">buffer</span>; <span class="comment">/* save the mysql multi responses data */</span></span><br><span class="line">    zval *result; <span class="comment">/* save the zval array result */</span></span><br><span class="line">&#125; mysql_statement;</span><br></pre></td></tr></table></figure><p>这样就可以实现以下代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$stmt1 = $db-&gt;prepare(<span class="string">'SELECT * FROM ckl LIMIT 1'</span>);</span><br><span class="line">$stmt1-&gt;execute();</span><br><span class="line">$stmt2 = $db-&gt;prepare(<span class="string">'SELECT * FROM ckl LIMIT 2'</span>);</span><br><span class="line">$stmt2-&gt;execute();</span><br><span class="line">$stmt1-&gt;fetchAll();</span><br><span class="line">$stmt2-&gt;fetchAll();</span><br></pre></td></tr></table></figure><p>因为现在result是挂在statement上的, 和client分离干净, 就不会因为这样的写法产生错误</p><p>当然这并没有多大用, <strong>主要还是为了后面处理多响应多结果集</strong></p><h2 id="分离mysql-parse-response"><a href="#分离mysql-parse-response" class="headerlink" title="分离mysql_parse_response"></a>分离mysql_parse_response</h2><p>这样就就可以在除了<code>onRead</code>回调之外的别的地方复用这个方法, 处理多结果集了</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程会返回多个响应, 如果和swoole之前的设计一样, 一次性全返回是不太现实的</p><p>PDO和MySQLi的设计都是用一个 next 方法来切换到下一个响应</p><p>刚开始是想做一个链表存储多个响应, 很快就发现并不需要</p><p>所以首先做了一个 <a href="https://github.com/twose/swoole-src/blob/13ff4ff8ac2723649f05b69f337f49557cf74546/swoole_mysql.c#L1478" target="_blank" rel="noopener"><code>mysql_is_over</code></a>方法</p><p>它用来<strong>校验MySQL包的完整性</strong>, 这是swoole以前没有的, 所以在之前的PR后虽然可以使用存储过程, 但是并不能每次都收到完整的响应包, 第一次没收到的包会被丢弃</p><p>然后说一下几个注意点</p><ol><li>MySQL协议决定了并不能倒着检查status flag, 我们必须把每个包的包头都扫描一遍, 通过package length快速扫描到最后一个已接收的包体, 这里只是每次只是检查每个包前几个字节, 消耗不大</li><li>MySQL其它包体中的 <code>MYSQL_SERVER_MORE_RESULTS_EXISTS</code> 的标志位并不准确, 不可采信, 只有<code>eof</code>和<code>ok</code>包中的是准确的 (这里一定要注意)</li><li>在存储过程中执行一个耗时操作的话, recv一次性收不完, 而且会等很久, 这时候需要return等下一次onRead触发(之前的代码里是continue阻塞), 这就不得不在client上加一个check_offset来保存上次完整性校验的位置, 从上个位置开始继续校验后续的MySQL包是否完整, 节省时间</li><li>存储过程中遇到错误(error响应)就可以直接终止接收了</li><li>在PHP7的zval使用上踩了点坑, 现在理解了, 幸好有鸟哥的文章<a href="https://github.com/laruence/php7-internal/blob/master/zval.md" target="_blank" rel="noopener">zval</a>给我解惑..</li></ol><p><strong>校验包的完整性直到所有数据接收完毕</strong></p><p>(分离了client和statement后, execute获取的数据是被存在<code>statement-&gt;buffer</code>里而不是<code>client-&gt;buffer</code>)</p><p><strong>这时候onRead中只会解析第一个响应的结果, 并置到statement对象上, 而剩下的数据仍在buffer中, 并等待nextResult来推动offset解析下一个, 可以说是懒解析了, 有时候会比一次性解析所有响应划算, 而且我们可以清楚的知道每一次nextResult切换前后, 对应的affected_rows和insert_id的值(如果一次性读完, 只能知道最后的)</strong></p><p>最后效果就是以下代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $db-&gt;prepare(<span class="string">'CALL reply(?)'</span>);</span><br><span class="line">$stmt-&gt;execute([<span class="string">'hello mysql!'</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    $res = $stmt-&gt;fetchAll();</span><br><span class="line">    var_dump($res);</span><br><span class="line">&#125; <span class="keyword">while</span> ($stmt-&gt;nextResult());</span><br></pre></td></tr></table></figure><p>非fetch_mode模式下这么写</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $db-&gt;prepare(<span class="string">'CALL reply(?)'</span>);</span><br><span class="line">$res = $stmt-&gt;execute([<span class="string">'hello mysql!'</span>]); <span class="comment">// the first result</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var_dump($res);</span><br><span class="line">&#125; <span class="keyword">while</span> ($res = $stmt-&gt;nextResult());</span><br></pre></td></tr></table></figure><p>比较巧妙的是nextResult推到最后一个response_ok包的时候会返回null, while循环终止, 我们就可以在循环后读取ok包的affected_rows, 如果最后存储过程最后一个语句是insert成功, 这里会显示1</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump($stmt-&gt;affected_rows); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>最近忙起来真的是很少时间能写文章了, 慢慢补吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是在一个月前了…那时候刚开始给swoole contribute代码, 初生牛犊, 修了不少小bug, 最后某位仁兄贴了个issue说swoole的mysql-client搞不掂存储过程, 当时我想想, 存储过程这东西实在没什么用, 甚至在很多大公司开发手册上是禁止使用的(某里粑粑), 具体的 &lt;a href=&quot;https://www.zhihu.com/question/57545650&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;为什么不要使用存储过程&lt;/strong&gt;&lt;/a&gt; 戳这里, 但是考虑到一个作为一个底层扩展, 各种用户都有, rango就给我分配了这个任务, 于是我就马上进行了一番研究.&lt;/p&gt;
&lt;p&gt;其实内容当时在PR里都贴了, &lt;a href=&quot;https://github.com/swoole/swoole-src/pull/1688&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/swoole/swoole-src/pull/1688&lt;/a&gt;, 现在在博客补个票&lt;/p&gt;
&lt;p&gt;完整的MySQL存储过程支持&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;做了以下几件事:&lt;/p&gt;
&lt;h2 id=&quot;fetch-mode&quot;&gt;&lt;a href=&quot;#fetch-mode&quot; class=&quot;headerlink&quot; title=&quot;fetch mode&quot;&gt;&lt;/a&gt;fetch mode&lt;/h2&gt;&lt;p&gt;一开始先想着和PDO一样给Swoole做一个fetch模式&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&#39;fetch_mode&#39;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;//连接配置里加入这个&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$stmt = $db-&amp;gt;prepare(&lt;span class=&quot;string&quot;&gt;&#39;SELECT `id` FROM `userinfo` LIMIT 2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$stmt-&amp;gt;execute(); &lt;span class=&quot;comment&quot;&gt;// true = success&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$stmt-&amp;gt;fetch(); &lt;span class=&quot;comment&quot;&gt;// result-set array 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$stmt-&amp;gt;fetch(); &lt;span class=&quot;comment&quot;&gt;// result-set array 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>PHP内核 - ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX 分析</title>
    <link href="http://www.twosee.cn/2018/07/15/php-zend-arg-info/"/>
    <id>http://www.twosee.cn/2018/07/15/php-zend-arg-info/</id>
    <published>2018-07-15T02:38:48.000Z</published>
    <updated>2018-07-16T16:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一部分内容抄自振宇哥的博客: <a href="http://kuangjue.com/article/70" target="_blank" rel="noopener">旷绝一世</a>, 在此基础后续扩写一部分</p><p>我们在写扩展的时候很常见的这样的宏，就比如swoole扩展中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_listen, 0, 0, 3)&#x2F;&#x2F;名字,unused,引用返回,参数个数</span><br><span class="line">  ZEND_ARG_INFO(0, host)</span><br><span class="line">  ZEND_ARG_INFO(0, port)</span><br><span class="line">  ZEND_ARG_INFO(0, sock_type)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br></pre></td></tr></table></figure><p>这个宏组合是用来定义函数的参数，我们不妨去跟下<code>ZEND_BEGIN_ARG_INFO_EX</code> 与<code>ZEND_END_ARG_INFO</code>的定义。<br>定义在zend_API.h文件中，<code>ZEND_BEGIN_ARG_INFO_EX</code>的定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_BEGIN_ARG_INFO_EX(name, _unused, return_reference, required_num_args)  \</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">const</span> zend_internal_arg_info name[] = &#123; \</span><br><span class="line">   &#123;(<span class="keyword">const</span> <span class="keyword">char</span>*)(<span class="keyword">zend_uintptr_t</span>)(required_num_args), <span class="number">0</span>, return_reference, <span class="number">0</span> &#125;,</span><br></pre></td></tr></table></figure><p>ZEND_END_ARG_INFO的定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ARG_INFO(pass_by_ref, name)&#123; #name, 0, pass_by_ref, 0&#125;,</span></span><br></pre></td></tr></table></figure><p>那么组合起来变成c代码就是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> zend_internal_arg_info arginfo_swoole_server_listen[] = &#123; \</span><br><span class="line">   &#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">   &#123; host, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">   &#123; port, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">   &#123; sock_type, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a id="more"></a></p><p>现在看来就是定义了一个zend_internal_arg_info结构数组，在zend/zend_compile.h文件中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_internal_arg_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;      <span class="comment">//参数名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *class_name;  <span class="comment">//当参数类型为类时，指定类的名称</span></span><br><span class="line">    zend_uchar type_hint;    <span class="comment">//参数类型是否为数组</span></span><br><span class="line">    zend_uchar pass_by_reference;  <span class="comment">//是否设置为引用，即&amp;</span></span><br><span class="line">    zend_bool allow_null;   <span class="comment">//是否允许设置为空</span></span><br><span class="line">    zend_bool is_variadic;<span class="comment">//**是否为可变参数**</span></span><br><span class="line">&#125; zend_internal_arg_info;</span><br></pre></td></tr></table></figure><p>PHP7中还加入了返回值类型声明这一新特性, 但是到目前为止, 各种扩展几乎没有添加返回值声明的意思, 但是这一特性对于IDE提示的生成非常有帮助</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(name, return_reference, required_num_args, type, allow_null) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> zend_internal_arg_info name[] = &#123; \</span><br><span class="line">&#123; (<span class="keyword">const</span> <span class="keyword">char</span>*)(<span class="keyword">zend_uintptr_t</span>)(required_num_args), ZEND_TYPE_ENCODE(type, allow_null), return_reference, <span class="number">0</span> &#125;,</span><br><span class="line"></span><br><span class="line">#define ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO(name, type, allow_null) \</span><br><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(name, <span class="number">0</span>, <span class="number">-1</span>, type, allow_null)</span><br></pre></td></tr></table></figure><p>在ZEND API头文件中我们可以看到新添加的宏<code>ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX</code>, 还有<code>ZEND_BEGIN_ARG_WITH_RETURN_OBJ_INFO_EX</code>等等</p><p>我们可以这样使用它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_OBJ_INFO_EX(arginfo_swoole_http2_client_coro_recv, <span class="number">0</span>, <span class="number">1</span>, Swoole\\Http2\\Response, <span class="number">0</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br><span class="line">    </span><br><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO(arginfo_swoole_http2_client_coro_balabala, _IS_BOOL, <span class="number">0</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br></pre></td></tr></table></figure><p>这样就可以为这个方法声明返回值类型了</p><p>当然, 我实际并没有这么做, 因为好像<code>ZEND_BEGIN_ARG_WITH_RETURN_OBJ_INFO_EX</code>这个宏在PHP7最初版本有<a href="https://github.com/php/php-src/commit/141d1ba9801f742dc5d9ccd06e02b94284c4deb7" target="_blank" rel="noopener">BUG</a>, 我们可以通过git blame看到几次修复, 而且并没有看到任何扩展使用了它, 如果要使用, 需要添加一些版本判断, 实在麻烦, 而且指不定会出什么问题, 这个需求也不是特别重要, 而且全部使用它工程量挺大的, 可能需要过一阵子再考虑统一添加一下</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一部分内容抄自振宇哥的博客: &lt;a href=&quot;http://kuangjue.com/article/70&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;旷绝一世&lt;/a&gt;, 在此基础后续扩写一部分&lt;/p&gt;
&lt;p&gt;我们在写扩展的时候很常见的这样的宏，就比如swoole扩展中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_listen, 0, 0, 3)&amp;#x2F;&amp;#x2F;名字,unused,引用返回,参数个数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ZEND_ARG_INFO(0, host)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ZEND_ARG_INFO(0, port)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ZEND_ARG_INFO(0, sock_type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ZEND_END_ARG_INFO()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个宏组合是用来定义函数的参数，我们不妨去跟下&lt;code&gt;ZEND_BEGIN_ARG_INFO_EX&lt;/code&gt; 与&lt;code&gt;ZEND_END_ARG_INFO&lt;/code&gt;的定义。&lt;br&gt;定义在zend_API.h文件中，&lt;code&gt;ZEND_BEGIN_ARG_INFO_EX&lt;/code&gt;的定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZEND_BEGIN_ARG_INFO_EX(name, _unused, return_reference, required_num_args)  \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; zend_internal_arg_info name[] = &amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;*)(&lt;span class=&quot;keyword&quot;&gt;zend_uintptr_t&lt;/span&gt;)(required_num_args), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, return_reference, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ZEND_END_ARG_INFO的定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZEND_ARG_INFO(pass_by_ref, name)&amp;#123; #name, 0, pass_by_ref, 0&amp;#125;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么组合起来变成c代码就是&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; zend_internal_arg_info arginfo_swoole_server_listen[] = &amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; host, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; port, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; sock_type, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://www.twosee.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下编译PHP所需的依赖库</title>
    <link href="http://www.twosee.cn/2018/06/13/Ubuntu-PHP/"/>
    <id>http://www.twosee.cn/2018/06/13/Ubuntu-PHP/</id>
    <published>2018-06-13T07:52:22.000Z</published>
    <updated>2018-06-14T04:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h4><p><code>sudo apt-get install -y build-essential</code></p><h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><p><code>sudo apt-get install -y libxml2-dev</code></p><h4 id="pcre"><a href="#pcre" class="headerlink" title="pcre"></a>pcre</h4><p><code>sudo apt-get install -y libpcre3-dev</code></p><h4 id="jpeg"><a href="#jpeg" class="headerlink" title="jpeg"></a>jpeg</h4><p><code>sudo apt-get install -y libjpeg62-dev</code></p><a id="more"></a><h4 id="freetype"><a href="#freetype" class="headerlink" title="freetype"></a>freetype</h4><p><code>sudo apt-get install -y libfreetype6-dev</code></p><h4 id="png"><a href="#png" class="headerlink" title="png"></a>png</h4><p><code>sudo apt-get install -y libpng12-dev libpng3 libpnglite-dev</code></p><h4 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a>iconv</h4><p><code>sudo apt-get install -y libiconv-hook-dev libiconv-hook1</code></p><h4 id="mycrypt"><a href="#mycrypt" class="headerlink" title="mycrypt"></a>mycrypt</h4><p><code>sudo apt-get install -y libmcrypt-dev libmcrypt4</code></p><h4 id="mhash"><a href="#mhash" class="headerlink" title="mhash"></a>mhash</h4><p><code>sudo apt-get install -y libmhash-dev libmhash2</code></p><h4 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h4><p><code>sudo apt-get install -y libltdl-dev libssl-dev</code></p><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p><code>sudo apt-get install -y libcurl4-openssl-dev</code></p><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p><code>sudo apt-get install -y libmysqlclient-dev</code></p><h4 id="imagick"><a href="#imagick" class="headerlink" title="imagick"></a>imagick</h4><p><code>sudo apt-get install -y libmagickcore-dev libmagickwand-dev</code></p><h4 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h4><p><code>sudo apt-get install -y libedit-dev</code></p><h4 id="ubuntu-无法找到-iconv"><a href="#ubuntu-无法找到-iconv" class="headerlink" title="ubuntu 无法找到 iconv"></a>ubuntu 无法找到 iconv</h4><p><code>sudo ln -s /usr/lib/libiconv_hook.so.1.0.0 /usr/lib/libiconv.so</code><br><code>sudo ln -s /usr/lib/libiconv_hook.so.1.0.0 /usr/lib/libiconv.so.1</code></p><h4 id="安装PHP扩展"><a href="#安装PHP扩展" class="headerlink" title="安装PHP扩展"></a>安装PHP扩展</h4><p><code>sudo apt-get install -y autoconf automake m4</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;编译环境&quot;&gt;&lt;a href=&quot;#编译环境&quot; class=&quot;headerlink&quot; title=&quot;编译环境&quot;&gt;&lt;/a&gt;编译环境&lt;/h4&gt;&lt;p&gt;&lt;code&gt;sudo apt-get install -y build-essential&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;xml&quot;&gt;&lt;a href=&quot;#xml&quot; class=&quot;headerlink&quot; title=&quot;xml&quot;&gt;&lt;/a&gt;xml&lt;/h4&gt;&lt;p&gt;&lt;code&gt;sudo apt-get install -y libxml2-dev&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;pcre&quot;&gt;&lt;a href=&quot;#pcre&quot; class=&quot;headerlink&quot; title=&quot;pcre&quot;&gt;&lt;/a&gt;pcre&lt;/h4&gt;&lt;p&gt;&lt;code&gt;sudo apt-get install -y libpcre3-dev&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;jpeg&quot;&gt;&lt;a href=&quot;#jpeg&quot; class=&quot;headerlink&quot; title=&quot;jpeg&quot;&gt;&lt;/a&gt;jpeg&lt;/h4&gt;&lt;p&gt;&lt;code&gt;sudo apt-get install -y libjpeg62-dev&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://www.twosee.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>并发,协程与烧开水问题</title>
    <link href="http://www.twosee.cn/2018/05/21/coroutine-boil-water/"/>
    <id>http://www.twosee.cn/2018/05/21/coroutine-boil-water/</id>
    <published>2018-05-21T07:22:42.000Z</published>
    <updated>2018-06-14T04:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言扯淡"><a href="#前言扯淡" class="headerlink" title="前言扯淡"></a>前言扯淡</h2><p>烧水是一件很神奇的事情, 首先有这么一个家喻户晓的传说故事:</p><p> “瓦特小的时候，看见炉子上壶里的水沸腾了。蒸汽把壶盖顶了起来，瓦特从中受到启发，长大后发明了蒸汽机，成为著名的发明家。”</p><p>当然，真实的蒸汽机的真正意义上发明也是类似的, “约1679年法国物理学家丹尼斯·巴本在观察蒸汽冒出他的高压锅后制造了第一台蒸汽机的工作模型”。后来，人类进入了蒸汽时代。</p><p>直到今天都没有找到能够替代”烧开水”获取能源的方案，这个有意思的概念来源于一个知乎问题<a href="https://www.zhihu.com/question/22355784" target="_blank" rel="noopener">人类的能源大多都是靠烧开水，这种说法正确吗？</a>，最后得出的结论是：我们寿命内，可用的能源主要来源靠烧水。</p><a id="more"></a><h2 id="烧开水问题"><a href="#烧开水问题" class="headerlink" title="烧开水问题"></a>烧开水问题</h2><p>当然，今天想说的协程之于烧开水问题，和上述烧开水没有一毛钱关系(狗头，而是与另外一个家喻户晓的烧开水问题息息相关：</p><blockquote><p>烧开水10分钟,洗衣机洗衣服21分钟,做作业20分钟,最少多少分钟完成这些事情</p></blockquote><p>这是我们小学时候常做的逻辑题，那时候心智不够，很容易掉进陷阱，没有能够<strong>调度</strong>各个任务的思维，把时间加在一起，这就是经典的<strong>同步阻塞</strong>：</p><ol><li>你烧水</li><li>等水开</li><li>水开后用洗衣机洗衣服</li><li>等衣服洗完</li><li>做作业</li></ol><p>而正解是，我们要给事件分类，哪些是可以并发且可并行的，哪些是需要单独做的：</p><ul><li>可并发并行的：洗衣机洗衣服，烧开水 </li><li>需要单独做的：做作业</li></ul><p>将他们类比成计算机的任务</p><ul><li>耗时任务，但不需要使用脑子(CPU)的：磁盘IO，可定时/后台运行的任务等</li><li>需要CPU密集计算处理的：业务逻辑，数据分析等</li></ul><p>那么就是:</p><ol><li>设定好洗衣机和烧上水 (发起并发请求), 挂起任务让出控制权(yield), 然后马上去写作业(CPU继续干活)</li><li>完成提示音通知你任务完成你可以收尾(事件回调)</li></ol><p>这样我们实际上耗费的时间就是 <code>CPU运算任务耗时 + Max(...可并发并行任务耗时)</code></p><p>这是这个问题最优解, 大脑(CPU)没有把时间浪费到无谓的等待中, 而(客户端)可并发特性使得两个请求可以同时开始，最后洗衣机的电子音和水壶的水烧开的声音会提醒你(Callback)让你收尾处理这两个事件的完成</p><h2 id="IO阻塞"><a href="#IO阻塞" class="headerlink" title="IO阻塞"></a>IO阻塞</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>我们可以看下面这样一段代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$data = file_get_contents(<span class="string">'./data.json'</span>);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br></pre></td></tr></table></figure><p>这是常见的文件读取操作, 在file_get_contents函数从磁盘中拿回文件数据前, 代码并不会继续运行, 而是等待返回, 因为后续的打印数据依赖上一条指令获取的数据的返回值, 这就是常见的同步编程.</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>我们再来看一个经典的jQuery时代的ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"foo"</span>,</span><br><span class="line">    data:<span class="number">1</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">"bar"</span>,</span><br><span class="line">            data:a,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: <span class="string">"baz"</span>,</span><br><span class="line">                    data:b,</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(c)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'lol~'</span>)</span><br></pre></td></tr></table></figure><p>代码在执行到ajax的时候, 函数会直接返回, 你马上就可以看到屏幕上欢快地打印出了<code>lol~</code></p><p>这就是异步, 这样你永远不会被IO阻塞, 但是它带来了新的问题, 在你运行到lol之后, 你就不知道现在代码运行到哪去了, 你只能等待回调被触发, 然后屏幕上打印出相应的log, 它的执行不是单层顺序的, 而是嵌套的.</p><p>如果在业务代码中, 这样的层层嵌套可读性可想而知.</p><h3 id="异步-1"><a href="#异步-1" class="headerlink" title="异步+"></a>异步+</h3><p>后来为了解决异步回调地狱, 发展出了Promise的方案, 这样的写法比回调要直观多了</p><p>以下代码引用自 <a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">理解 JavaScript 的 async/await</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="comment">//promise的链式调用,比callback清晰多了</span></span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure><h3 id="异步-2"><a href="#异步-2" class="headerlink" title="异步++"></a>异步++</h3><p>Promise以后, 又进化出了async/await语法糖, 可以说是异步终极方案了, 看起来简直就跟同步代码一模一样!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>其实在实际的程序中, 磁盘IO等阻塞的时间是远远大于CPU运算时间的, <strong>根据Amdahl定理, 你想要加速一个系统, 必须提升全系统中相当大的部分的速度</strong>, 而现在的大部分WEB服务, <strong>瓶颈都在数据库IO而非密集运算</strong>, 大家可以参考一篇文章: <a href="http://twosee.cn/2017/12/28/how-slow-is-disk-and-network/" target="_blank" rel="noopener">让 CPU 告诉你硬盘和网络到底有多慢</a>，这篇文章很形象地告诉了你, IO是如何把团队发育带崩的：</p><p><strong>如果假设CPU执行一个指令需要1秒, 那么磁盘寻址花费的时间就是10个月, 从磁盘读取 1MB 连续数据需要20个月! 而如果是网络IO, 很可能达到十数年甚至更久!</strong></p><p>也就是说, 在IO等待的时候, CPU足足荒废了几年的美好光阴!</p><p>让我们来看看这张经典的存储器层次结构示例:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWly1frpv6p5dnmj30vn0h5tc2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所以如果能把IO阻塞浪费的时间优化掉, 就可以提升了多倍的并发处理能力, 比起优化代码逻辑和算法的收益更加可观, 因此而节省的硬件成本也相当可观(否则你会陷入不断加机器/换SSD/加内存做cache的困扰中)</p><h2 id="协程不能解决的问题"><a href="#协程不能解决的问题" class="headerlink" title="协程不能解决的问题"></a>协程不能解决的问题</h2><blockquote><p>小学课上，女孩对男孩说“蒸一个包子要3分钟，那蒸3个包子要几分钟”，男孩说“9分钟”，女孩说你傻呀，你家蒸包子是一个一个地蒸啊…然后男孩对女孩说“吃一个苹果要一分钟，那吃9个苹果要几分钟”，女孩说你以为我和你一样傻啊，当然是9分钟了。男孩什么也没说，直接拿了9个苹果放到女孩面前说你9分钟把它们都吃完吧……</p></blockquote><p>包子可以一起蒸, 是因为一个正常蒸笼(预防杠精)有蒸三个正常包子(预防杠精)的能力</p><p>苹果只能一个个吃, 是因为正常人一般(预防杠精)只有一次吃一个正常苹果(预防杠精)的能力</p><p>所以协程不能解决的问题是: <strong>它不能解决你数据库的上限瓶颈, 数据库能承受多少压力, 它还是多少</strong></p><p>(已做连接池的情况下, 连接池是常驻内存运行的福利, 和协程无关)</p><p>有人在PHPcon上问Rango: “韩老师, 我们的业务在高并发的时候, redis数据库很容易被击穿, 这该怎么办?”</p><p>Rango就答了: “这不是swoole可以解决的问题, 你可以了解下<code>twemproxy</code></p><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>这两个词对于编程新手就像<code>/</code>和<code>\</code>两个符号一样难以记忆, 网上也没有看到一个比较好又形象的通俗解释, 在这里我可以给出一种不错的记忆方法:</p><p>并发可以理解为客户端的一个特性, 客户端可以一次性发出多个请求, 称之为<code>并发</code>.</p><p>并行可以理解为服务器同时能处理任务的这个能力, 比如一般来说, MySQL一个连接就是一个线程, 如果不使用线程池等技术, 它所能创建线程数量就是它可以<code>并行</code>处理请求的能力.</p><p>并发: 同时发出(请求)</p><p>并行: 同时执行(任务)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言扯淡&quot;&gt;&lt;a href=&quot;#前言扯淡&quot; class=&quot;headerlink&quot; title=&quot;前言扯淡&quot;&gt;&lt;/a&gt;前言扯淡&lt;/h2&gt;&lt;p&gt;烧水是一件很神奇的事情, 首先有这么一个家喻户晓的传说故事:&lt;/p&gt;
&lt;p&gt; “瓦特小的时候，看见炉子上壶里的水沸腾了。蒸汽把壶盖顶了起来，瓦特从中受到启发，长大后发明了蒸汽机，成为著名的发明家。”&lt;/p&gt;
&lt;p&gt;当然，真实的蒸汽机的真正意义上发明也是类似的, “约1679年法国物理学家丹尼斯·巴本在观察蒸汽冒出他的高压锅后制造了第一台蒸汽机的工作模型”。后来，人类进入了蒸汽时代。&lt;/p&gt;
&lt;p&gt;直到今天都没有找到能够替代”烧开水”获取能源的方案，这个有意思的概念来源于一个知乎问题&lt;a href=&quot;https://www.zhihu.com/question/22355784&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;人类的能源大多都是靠烧开水，这种说法正确吗？&lt;/a&gt;，最后得出的结论是：我们寿命内，可用的能源主要来源靠烧水。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coroutine" scheme="http://www.twosee.cn/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>[整理] MySQL协议分析</title>
    <link href="http://www.twosee.cn/2018/05/15/mysql-protocol/"/>
    <id>http://www.twosee.cn/2018/05/15/mysql-protocol/</id>
    <published>2018-05-15T08:05:26.000Z</published>
    <updated>2018-06-14T17:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p><h2 id="1-交互过程"><a href="#1-交互过程" class="headerlink" title="1 交互过程"></a>1 交互过程</h2><p>MySQL客户端与服务器的交互主要分为两个阶段：握手认证阶段和命令执行阶段。</p><h3 id="1-1-握手认证阶段"><a href="#1-1-握手认证阶段" class="headerlink" title="1.1 握手认证阶段"></a>1.1 握手认证阶段</h3><p>握手认证阶段为客户端与服务器建立连接后进行，交互过程如下：</p><ul><li>服务器 -&gt; 客户端：握手初始化消息</li><li>客户端 -&gt; 服务器：登陆认证消息</li><li>服务器 -&gt; 客户端：认证结果消息</li></ul><h3 id="1-2-命令执行阶段"><a href="#1-2-命令执行阶段" class="headerlink" title="1.2 命令执行阶段"></a>1.2 命令执行阶段</h3><p>客户端认证成功后，会进入命令执行阶段，交互过程如下：</p><ul><li>客户端 -&gt; 服务器：执行命令消息</li><li>服务器 -&gt; 客户端：命令执行结果</li></ul><a id="more"></a><p><strong>MySQL客户端与服务器的完整交互过程如下</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWly1fsb7y00rsyj30cc0ddwew.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2 基本类型"></a>2 基本类型</h2><h3 id="2-1-整型值"><a href="#2-1-整型值" class="headerlink" title="2.1 整型值"></a>2.1 整型值</h3><p>MySQL报文中整型值分别有1、2、3、4、8字节长度，使用小字节序传输。</p><h3 id="2-2-字符串（以NULL结尾）（Null-Terminated-String）"><a href="#2-2-字符串（以NULL结尾）（Null-Terminated-String）" class="headerlink" title="2.2 字符串（以NULL结尾）（Null-Terminated String）"></a>2.2 字符串（以NULL结尾）（Null-Terminated String）</h3><p>字符串长度不固定，当遇到’NULL’（0x00）字符时结束。</p><h3 id="2-3-二进制数据（长度编码）（Length-Coded-Binary）"><a href="#2-3-二进制数据（长度编码）（Length-Coded-Binary）" class="headerlink" title="2.3 二进制数据（长度编码）（Length Coded Binary）"></a>2.3 二进制数据（长度编码）（Length Coded Binary）</h3><p>数据长度不固定，长度值由数据前的1-9个字节决定，其中长度值所占的字节数不定，字节数由第1个字节决定，如下表：</p><table><thead><tr><th>第一个字节值</th><th>后续字节数</th><th>长度值说明</th></tr></thead><tbody><tr><td>0-250</td><td>0</td><td>第一个字节值即为数据的真实长度</td></tr><tr><td>251</td><td>0</td><td>空数据，数据的真实长度为零</td></tr><tr><td>252</td><td>2</td><td>后续额外2个字节标识了数据的真实长度</td></tr><tr><td>253</td><td>3</td><td>后续额外3个字节标识了数据的真实长度</td></tr><tr><td>254</td><td>8</td><td>后续额外8个字节标识了数据的真实长度</td></tr></tbody></table><h3 id="2-4-字符串（长度编码）（Length-Coded-String）"><a href="#2-4-字符串（长度编码）（Length-Coded-String）" class="headerlink" title="2.4 字符串（长度编码）（Length Coded String）"></a>2.4 字符串（长度编码）（Length Coded String）</h3><p>字符串长度不固定，无’NULL’（0x00）结束符，编码方式与上面的 Length Coded Binary 相同。</p><h2 id="3-报文结构"><a href="#3-报文结构" class="headerlink" title="3 报文结构"></a>3 报文结构</h2><p>报文分为消息头和消息体两部分，其中消息头占用固定的4个字节，消息体长度由消息头中的长度字段决定，报文结构如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_struct.png" alt="MySQL报文结构" title="">                </div>                <div class="image-caption">MySQL报文结构</div>            </figure><h3 id="3-1-消息头"><a href="#3-1-消息头" class="headerlink" title="3.1 消息头"></a>3.1 消息头</h3><h4 id="3-1-1-报文长度"><a href="#3-1-1-报文长度" class="headerlink" title="3.1.1 报文长度"></a>3.1.1 报文长度</h4><p>用于标记当前请求消息的实际数据长度值，以字节为单位，占用3个字节，最大值为 0xFFFFFF，即接近 16 MB 大小（比16MB少1个字节）。</p><h4 id="3-1-2-序号"><a href="#3-1-2-序号" class="headerlink" title="3.1.2 序号"></a>3.1.2 序号</h4><p>在一次完整的请求/响应交互过程中，用于保证消息顺序的正确，每次客户端发起请求时，序号值都会从0开始计算。</p><h3 id="3-2-消息体"><a href="#3-2-消息体" class="headerlink" title="3.2 消息体"></a>3.2 消息体</h3><p>消息体用于存放请求的内容及响应的数据，长度由消息头中的长度值决定。</p><h2 id="4-报文类型"><a href="#4-报文类型" class="headerlink" title="4 报文类型"></a>4 报文类型</h2><h3 id="4-1-登陆认证交互报文"><a href="#4-1-登陆认证交互报文" class="headerlink" title="4.1 登陆认证交互报文"></a>4.1 登陆认证交互报文</h3><h4 id="4-1-1-握手初始化报文（服务器-gt-客户端）"><a href="#4-1-1-握手初始化报文（服务器-gt-客户端）" class="headerlink" title="4.1.1 握手初始化报文（服务器 -&gt; 客户端）"></a>4.1.1 握手初始化报文（服务器 -&gt; 客户端）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_handshake.png" alt="MySQL握手初始化报文" title="">                </div>                <div class="image-caption">MySQL握手初始化报文</div>            </figure><p><strong>服务协议版本号</strong>：该值由 PROTOCOL_VERSION 宏定义决定（参考MySQL源代码<code>/include/mysql_version.h</code>头文件定义）</p><p><strong>服务版本信息</strong>：该值为字符串，由 MYSQL_SERVER_VERSION 宏定义决定（参考MySQL源代码<code>/include/mysql_version.h</code>头文件定义）</p><p><strong>服务器线程ID</strong>：服务器为当前连接所创建的线程ID。</p><p><strong>挑战随机数</strong>：MySQL数据库用户认证采用的是挑战/应答的方式，服务器生成该挑战数并发送给客户端，由客户端进行处理并返回相应结果，然后服务器检查是否与预期的结果相同，从而完成用户认证的过程。</p><p><strong>服务器权能标志</strong>：用于与客户端协商通讯方式，各标志位含义如下（参考MySQL源代码<code>/include/mysql_com.h</code>中的宏定义）：</p><table><thead><tr><th>标志位名称</th><th>标志位</th><th>说明</th></tr></thead><tbody><tr><td>CLIENT_LONG_PASSWORD</td><td>0x0001</td><td>new more secure passwords</td></tr><tr><td>CLIENT_FOUND_ROWS</td><td>0x0002</td><td>Found instead of affected rows</td></tr><tr><td>CLIENT_LONG_FLAG</td><td>0x0004</td><td>Get all column flags</td></tr><tr><td>CLIENT_CONNECT_WITH_DB</td><td>0x0008</td><td>One can specify db on connect</td></tr><tr><td>CLIENT_NO_SCHEMA</td><td>0x0010</td><td>Do not allow database.table.column</td></tr><tr><td>CLIENT_COMPRESS</td><td>0x0020</td><td>Can use compression protocol</td></tr><tr><td>CLIENT_ODBC</td><td>0x0040</td><td>Odbc client</td></tr><tr><td>CLIENT_LOCAL_FILES</td><td>0x0080</td><td>Can use LOAD DATA LOCAL</td></tr><tr><td>CLIENT_IGNORE_SPACE</td><td>0x0100</td><td>Ignore spaces before ‘(‘</td></tr><tr><td>CLIENT_PROTOCOL_41</td><td>0x0200</td><td>New 4.1 protocol</td></tr><tr><td>CLIENT_INTERACTIVE</td><td>0x0400</td><td>This is an interactive client</td></tr><tr><td>CLIENT_SSL</td><td>0x0800</td><td>Switch to SSL after handshake</td></tr><tr><td>CLIENT_IGNORE_SIGPIPE</td><td>0x1000</td><td>IGNORE sigpipes</td></tr><tr><td>CLIENT_TRANSACTIONS</td><td>0x2000</td><td>Client knows about transactions</td></tr><tr><td>CLIENT_RESERVED</td><td>0x4000</td><td>Old flag for 4.1 protocol</td></tr><tr><td>CLIENT_SECURE_CONNECTION</td><td>0x8000</td><td>New 4.1 authentication</td></tr><tr><td>CLIENT_MULTI_STATEMENTS</td><td>0x0001 0000</td><td>Enable/disable multi-stmt support</td></tr><tr><td>CLIENT_MULTI_RESULTS</td><td>0x0002 0000</td><td>Enable/disable multi-results</td></tr></tbody></table><p><strong>字符编码</strong>：标识服务器所使用的字符集。</p><p><strong>服务器状态</strong>：状态值定义如下（参考MySQL源代码<code>/include/mysql_com.h</code>中的宏定义）：</p><table><thead><tr><th>状态名称</th><th>状态值</th></tr></thead><tbody><tr><td>SERVER_STATUS_IN_TRANS</td><td>0x0001</td></tr><tr><td>SERVER_STATUS_AUTOCOMMIT</td><td>0x0002</td></tr><tr><td>SERVER_STATUS_CURSOR_EXISTS</td><td>0x0040</td></tr><tr><td>SERVER_STATUS_LAST_ROW_SENT</td><td>0x0080</td></tr><tr><td>SERVER_STATUS_DB_DROPPED</td><td>0x0100</td></tr><tr><td>SERVER_STATUS_NO_BACKSLASH_ESCAPES</td><td>0x0200</td></tr><tr><td>SERVER_STATUS_METADATA_CHANGED</td><td>0x0400</td></tr></tbody></table><h4 id="4-1-2-登陆认证报文（客户端-gt-服务器）"><a href="#4-1-2-登陆认证报文（客户端-gt-服务器）" class="headerlink" title="4.1.2 登陆认证报文（客户端 -&gt; 服务器）"></a>4.1.2 登陆认证报文（客户端 -&gt; 服务器）</h4><p><strong>MySQL 4.0 及之前的版本</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_auth_40.png" alt="MySQL登陆认证报文(4.0及之前的版本)" title="">                </div>                <div class="image-caption">MySQL登陆认证报文(4.0及之前的版本)</div>            </figure><p><strong>MySQL 4.1 及之后的版本</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_auth_41.png" alt="MySQL登陆认证报文(4.1及之后的版本)" title="">                </div>                <div class="image-caption">MySQL登陆认证报文(4.1及之后的版本)</div>            </figure><p><strong>客户端权能标志</strong>：用于与客户端协商通讯方式，标志位含义与握手初始化报文中的相同。客户端收到服务器发来的初始化报文后，会对服务器发送的权能标志进行修改，保留自身所支持的功能，然后将权能标返回给服务器，从而保证服务器与客户端通讯的兼容性。</p><p><strong>最大消息长度</strong>：客户端发送请求报文时所支持的最大消息长度值。</p><p><strong>字符编码</strong>：标识通讯过程中使用的字符编码，与服务器在认证初始化报文中发送的相同。</p><p><strong>用户名</strong>：客户端登陆用户的用户名称。</p><p><strong>挑战认证数据</strong>：客户端用户密码使用服务器发送的挑战随机数进行加密后，生成挑战认证数据，然后返回给服务器，用于对用户身份的认证。</p><p><strong>数据库名称</strong>：当客户端的权能标志位 CLIENT_CONNECT_WITH_DB 被置位时，该字段必须出现。</p><h3 id="4-2-客户端命令请求报文（客户端-gt-服务器）"><a href="#4-2-客户端命令请求报文（客户端-gt-服务器）" class="headerlink" title="4.2 客户端命令请求报文（客户端 -&gt; 服务器）"></a>4.2 客户端命令请求报文（客户端 -&gt; 服务器）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_command.png" alt="MySQL客户端命令请求报文" title="">                </div>                <div class="image-caption">MySQL客户端命令请求报文</div>            </figure><p><strong>命令</strong>：用于标识当前请求消息的类型，例如切换数据库（0x02）、查询命令（0x03）等。命令值的取值范围及说明如下表（参考MySQL源代码<code>/include/mysql_com.h</code>头文件中的定义）：</p><table><thead><tr><th>类型值</th><th>命令</th><th>功能</th><th>关联函数</th></tr></thead><tbody><tr><td>0x00</td><td>COM_SLEEP</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x01</td><td>COM_QUIT</td><td>关闭连接</td><td>mysql_close</td></tr><tr><td>0x02</td><td>COM_INIT_DB</td><td>切换数据库</td><td>mysql_select_db</td></tr><tr><td>0x03</td><td>COM_QUERY</td><td>SQL查询请求</td><td>mysql_real_query</td></tr><tr><td>0x04</td><td>COM_FIELD_LIST</td><td>获取数据表字段信息</td><td>mysql_list_fields</td></tr><tr><td>0x05</td><td>COM_CREATE_DB</td><td>创建数据库</td><td>mysql_create_db</td></tr><tr><td>0x06</td><td>COM_DROP_DB</td><td>删除数据库</td><td>mysql_drop_db</td></tr><tr><td>0x07</td><td>COM_REFRESH</td><td>清除缓存</td><td>mysql_refresh</td></tr><tr><td>0x08</td><td>COM_SHUTDOWN</td><td>停止服务器</td><td>mysql_shutdown</td></tr><tr><td>0x09</td><td>COM_STATISTICS</td><td>获取服务器统计信息</td><td>mysql_stat</td></tr><tr><td>0x0A</td><td>COM_PROCESS_INFO</td><td>获取当前连接的列表</td><td>mysql_list_processes</td></tr><tr><td>0x0B</td><td>COM_CONNECT</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x0C</td><td>COM_PROCESS_KILL</td><td>中断某个连接</td><td>mysql_kill</td></tr><tr><td>0x0D</td><td>COM_DEBUG</td><td>保存服务器调试信息</td><td>mysql_dump_debug_info</td></tr><tr><td>0x0E</td><td>COM_PING</td><td>测试连通性</td><td>mysql_ping</td></tr><tr><td>0x0F</td><td>COM_TIME</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x10</td><td>COM_DELAYED_INSERT</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x11</td><td>COM_CHANGE_USER</td><td>重新登陆（不断连接）</td><td>mysql_change_user</td></tr><tr><td>0x12</td><td>COM_BINLOG_DUMP</td><td>获取二进制日志信息</td><td>（无）</td></tr><tr><td>0x13</td><td>COM_TABLE_DUMP</td><td>获取数据表结构信息</td><td>（无）</td></tr><tr><td>0x14</td><td>COM_CONNECT_OUT</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x15</td><td>COM_REGISTER_SLAVE</td><td>从服务器向主服务器进行注册</td><td>（无）</td></tr><tr><td>0x16</td><td>COM_STMT_PREPARE</td><td>预处理SQL语句</td><td>mysql_stmt_prepare</td></tr><tr><td>0x17</td><td>COM_STMT_EXECUTE</td><td>执行预处理语句</td><td>mysql_stmt_execute</td></tr><tr><td>0x18</td><td>COM_STMT_SEND_LONG_DATA</td><td>发送BLOB类型的数据</td><td>mysql_stmt_send_long_data</td></tr><tr><td>0x19</td><td>COM_STMT_CLOSE</td><td>销毁预处理语句</td><td>mysql_stmt_close</td></tr><tr><td>0x1A</td><td>COM_STMT_RESET</td><td>清除预处理语句参数缓存</td><td>mysql_stmt_reset</td></tr><tr><td>0x1B</td><td>COM_SET_OPTION</td><td>设置语句选项</td><td>mysql_set_server_option</td></tr><tr><td>0x1C</td><td>COM_STMT_FETCH</td><td>获取预处理语句的执行结果</td><td>mysql_stmt_fetch</td></tr></tbody></table><p><strong>参数</strong>：内容是用户在MySQL客户端输入的命令（不包括每行命令结尾的”;”分号）。另外这个字段的字符串不是以NULL字符结尾，而是通过消息头中的长度值计算而来。</p><p>例如：当我们在MySQL客户端中执行<code>use hutaow;</code>命令时（切换到<code>hutaow</code>数据库），发送的请求报文数据会是下面的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x02 0x68 0x75 0x74 0x61 0x6f 0x77</span><br></pre></td></tr></table></figure><p>其中，<code>0x02</code>为请求类型值<code>COM_INIT_DB</code>，后面的<code>0x68 0x75 0x74 0x61 0x6f 0x77</code>为ASCII字符<code>hutaow</code>。</p><h4 id="4-2-1-COM-QUIT-消息报文"><a href="#4-2-1-COM-QUIT-消息报文" class="headerlink" title="4.2.1 COM_QUIT 消息报文"></a>4.2.1 COM_QUIT 消息报文</h4><p><strong>功能</strong>：关闭当前连接（客户端退出），无参数。</p><h4 id="4-2-2-COM-INIT-DB-消息报文"><a href="#4-2-2-COM-INIT-DB-消息报文" class="headerlink" title="4.2.2 COM_INIT_DB 消息报文"></a>4.2.2 COM_INIT_DB 消息报文</h4><p><strong>功能</strong>：切换数据库，对应的SQL语句为<code>USE &lt;database&gt;</code>。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-3-COM-QUERY-消息报文"><a href="#4-2-3-COM-QUERY-消息报文" class="headerlink" title="4.2.3 COM_QUERY 消息报文"></a>4.2.3 COM_QUERY 消息报文</h4><p><strong>功能</strong>：最常见的请求消息类型，当用户执行SQL语句时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>SQL语句（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-4-COM-FIELD-LIST-消息报文"><a href="#4-2-4-COM-FIELD-LIST-消息报文" class="headerlink" title="4.2.4 COM_FIELD_LIST 消息报文"></a>4.2.4 COM_FIELD_LIST 消息报文</h4><p><strong>功能</strong>：查询某表的字段（列）信息，等同于SQL语句<code>SHOW [FULL] FIELDS FROM ...</code>。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>表格名称（Null-Terminated String）</td></tr><tr><td>n</td><td>字段（列）名称或通配符（可选）</td></tr></tbody></table><h4 id="4-2-5-COM-CREATE-DB-消息报文"><a href="#4-2-5-COM-CREATE-DB-消息报文" class="headerlink" title="4.2.5 COM_CREATE_DB 消息报文"></a>4.2.5 COM_CREATE_DB 消息报文</h4><p><strong>功能</strong>：创建数据库，该消息已过时，而被SQL语句<code>CREATE DATABASE</code>代替。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-6-COM-DROP-DB-消息报文"><a href="#4-2-6-COM-DROP-DB-消息报文" class="headerlink" title="4.2.6 COM_DROP_DB 消息报文"></a>4.2.6 COM_DROP_DB 消息报文</h4><p><strong>功能</strong>：删除数据库，该消息已过时，而被SQL语句<code>DROP DATABASE</code>代替。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-7-COM-REFRESH-消息报文"><a href="#4-2-7-COM-REFRESH-消息报文" class="headerlink" title="4.2.7 COM_REFRESH 消息报文"></a>4.2.7 COM_REFRESH 消息报文</h4><p><strong>功能</strong>：清除缓存，等同于SQL语句<code>FLUSH</code>，或是执行<code>mysqladmin flush-foo</code>命令时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>清除缓存选项（位图方式存储，各标志位含义如下）</td></tr><tr><td></td><td>0x01: REFRESH_GRANT</td></tr><tr><td></td><td>0x02: REFRESH_LOG</td></tr><tr><td></td><td>0x04: REFRESH_TABLES</td></tr><tr><td></td><td>0x08: REFRESH_HOSTS</td></tr><tr><td></td><td>0x10: REFRESH_STATUS</td></tr><tr><td></td><td>0x20: REFRESH_THREADS</td></tr><tr><td></td><td>0x40: REFRESH_SLAVE</td></tr><tr><td></td><td>0x80: REFRESH_MASTER</td></tr></tbody></table><h4 id="4-2-8-COM-SHUTDOWN-消息报文"><a href="#4-2-8-COM-SHUTDOWN-消息报文" class="headerlink" title="4.2.8 COM_SHUTDOWN 消息报文"></a>4.2.8 COM_SHUTDOWN 消息报文</h4><p><strong>功能</strong>：停止MySQL服务。执行<code>mysqladmin shutdown</code>命令时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>停止服务选项</td></tr><tr><td></td><td>0x00: SHUTDOWN_DEFAULT</td></tr><tr><td></td><td>0x01: SHUTDOWN_WAIT_CONNECTIONS</td></tr><tr><td></td><td>0x02: SHUTDOWN_WAIT_TRANSACTIONS</td></tr><tr><td></td><td>0x08: SHUTDOWN_WAIT_UPDATES</td></tr><tr><td></td><td>0x10: SHUTDOWN_WAIT_ALL_BUFFERS</td></tr><tr><td></td><td>0x11: SHUTDOWN_WAIT_CRITICAL_BUFFERS</td></tr><tr><td></td><td>0xFE: KILL_QUERY</td></tr><tr><td></td><td>0xFF: KILL_CONNECTION</td></tr></tbody></table><h4 id="4-2-9-COM-STATISTICS-消息报文"><a href="#4-2-9-COM-STATISTICS-消息报文" class="headerlink" title="4.2.9 COM_STATISTICS 消息报文"></a>4.2.9 COM_STATISTICS 消息报文</h4><p><strong>功能</strong>：查看MySQL服务的统计信息（例如运行时间、每秒查询次数等）。执行<code>mysqladmin status</code>命令时发送该消息，无参数。</p><h4 id="4-2-10-COM-PROCESS-INFO-消息报文"><a href="#4-2-10-COM-PROCESS-INFO-消息报文" class="headerlink" title="4.2.10 COM_PROCESS_INFO 消息报文"></a>4.2.10 COM_PROCESS_INFO 消息报文</h4><p><strong>功能</strong>：获取当前活动的线程（连接）列表。等同于SQL语句<code>SHOW PROCESSLIST</code>，或是执行<code>mysqladmin processlist</code>命令时发送该消息，无参数。</p><h4 id="4-2-11-COM-PROCESS-KILL-消息报文"><a href="#4-2-11-COM-PROCESS-KILL-消息报文" class="headerlink" title="4.2.11 COM_PROCESS_KILL 消息报文"></a>4.2.11 COM_PROCESS_KILL 消息报文</h4><p><strong>功能</strong>：要求服务器中断某个连接。等同于SQL语句<code>KILL &lt;id&gt;</code>。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>连接ID号（小字节序）</td></tr></tbody></table><h4 id="4-2-12-COM-DEBUG-消息报文"><a href="#4-2-12-COM-DEBUG-消息报文" class="headerlink" title="4.2.12 COM_DEBUG 消息报文"></a>4.2.12 COM_DEBUG 消息报文</h4><p><strong>功能</strong>：要求服务器将调试信息保存下来，保存的信息多少依赖于编译选项设置（debug=no|yes|full）。执行<code>mysqladmin debug</code>命令时发送该消息，无参数。</p><h4 id="4-2-13-COM-PING-消息报文"><a href="#4-2-13-COM-PING-消息报文" class="headerlink" title="4.2.13 COM_PING 消息报文"></a>4.2.13 COM_PING 消息报文</h4><p><strong>功能</strong>：该消息用来测试连通性，同时会将服务器的无效连接（超时）计数器清零。执行<code>mysqladmin ping</code>命令时发送该消息，无参数。</p><h4 id="4-2-14-COM-CHANGE-USER-消息报文"><a href="#4-2-14-COM-CHANGE-USER-消息报文" class="headerlink" title="4.2.14 COM_CHANGE_USER 消息报文"></a>4.2.14 COM_CHANGE_USER 消息报文</h4><p><strong>功能</strong>：在不断连接的情况下重新登陆，该操作会销毁MySQL服务器端的会话上下文（包括临时表、会话变量等）。有些连接池用这种方法实现清除会话上下文。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>用户名（字符串以NULL结尾）</td></tr><tr><td>n</td><td>密码（挑战数）</td></tr><tr><td></td><td>MySQL 3.23 版本：Null-Terminated String（长度9字节）</td></tr><tr><td></td><td>MySQL 4.1 版本：Length Coded String（长度1+21字节）</td></tr><tr><td>n</td><td>数据库名称（Null-Terminated String）</td></tr><tr><td>2</td><td>字符编码</td></tr></tbody></table><h4 id="4-2-15-COM-BINLOG-DUMP-消息报文"><a href="#4-2-15-COM-BINLOG-DUMP-消息报文" class="headerlink" title="4.2.15 COM_BINLOG_DUMP 消息报文"></a>4.2.15 COM_BINLOG_DUMP 消息报文</h4><p><strong>功能</strong>：该消息是备份连接时由从服务器向主服务器发送的最后一个请求，主服务器收到后，会响应一系列的报文，每个报文都包含一个二进制日志事件。如果主服务器出现故障时，会发送一个EOF报文。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>二进制日志数据的起始位置（小字节序）</td></tr><tr><td>4</td><td>二进制日志数据标志位（目前未使用，永远为0x00）</td></tr><tr><td>4</td><td>从服务器的服务器ID值（小字节序）</td></tr><tr><td>n</td><td>二进制日志的文件名称（可选，默认值为主服务器上第一个有效的文件名）</td></tr></tbody></table><h4 id="4-2-16-COM-TABLE-DUMP-消息报文"><a href="#4-2-16-COM-TABLE-DUMP-消息报文" class="headerlink" title="4.2.16 COM_TABLE_DUMP 消息报文"></a>4.2.16 COM_TABLE_DUMP 消息报文</h4><p><strong>功能</strong>：将数据表从主服务器复制到从服务器中，执行SQL语句<code>LOAD TABLE ... FROM MASTER</code>时发送该消息。目前该消息已过时，不再使用。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（Length Coded String）</td></tr><tr><td>n</td><td>数据表名称（Length Coded String）</td></tr></tbody></table><h4 id="4-2-17-COM-REGISTER-SLAVE-消息报文"><a href="#4-2-17-COM-REGISTER-SLAVE-消息报文" class="headerlink" title="4.2.17 COM_REGISTER_SLAVE 消息报文"></a>4.2.17 COM_REGISTER_SLAVE 消息报文</h4><p><strong>功能</strong>：在从服务器<code>report_host</code>变量设置的情况下，当备份连接时向主服务器发送的注册消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>从服务器ID值（小字节序）</td></tr><tr><td>n</td><td>主服务器IP地址（Length Coded String）</td></tr><tr><td>n</td><td>主服务器用户名（Length Coded String）</td></tr><tr><td>n</td><td>主服务器密码（Length Coded String）</td></tr><tr><td>2</td><td>主服务器端口号</td></tr><tr><td>4</td><td>安全备份级别（由MySQL服务器<code>rpl_recovery_rank</code>变量设置，暂时未使用）</td></tr><tr><td>4</td><td>主服务器ID值（值恒为0x00）</td></tr></tbody></table><h4 id="4-2-18-COM-PREPARE-消息报文"><a href="#4-2-18-COM-PREPARE-消息报文" class="headerlink" title="4.2.18 COM_PREPARE 消息报文"></a>4.2.18 COM_PREPARE 消息报文</h4><p><strong>功能</strong>：预处理SQL语句，使用带有”?”占位符的SQL语句时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>带有”?”占位符的SQL语句（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-19-COM-EXECUTE-消息报文"><a href="#4-2-19-COM-EXECUTE-消息报文" class="headerlink" title="4.2.19 COM_EXECUTE 消息报文"></a>4.2.19 COM_EXECUTE 消息报文</h4><p><strong>功能</strong>：执行预处理语句。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值</td></tr><tr><td>1</td><td>标志位</td></tr><tr><td></td><td>0x00: CURSOR_TYPE_NO_CURSOR</td></tr><tr><td></td><td>0x01: CURSOR_TYPE_READ_ONLY</td></tr><tr><td></td><td>0x02: CURSOR_TYPE_FOR_UPDATE</td></tr><tr><td></td><td>0x04: CURSOR_TYPE_SCROLLABLE</td></tr><tr><td>4</td><td>保留（值恒为0x01）</td></tr><tr><td>如果参数数量大于0</td><td></td></tr><tr><td>n</td><td>空位图（Null-Bitmap，长度 = (参数数量 + 7) / 8 字节）</td></tr><tr><td>1</td><td>参数分隔标志</td></tr><tr><td>如果参数分隔标志值为1</td><td></td></tr><tr><td>n</td><td>每个参数的类型值（长度 = 参数数量 * 2 字节）</td></tr><tr><td>n</td><td>每个参数的值</td></tr></tbody></table><h4 id="4-2-20-COM-LONG-DATA-消息报文"><a href="#4-2-20-COM-LONG-DATA-消息报文" class="headerlink" title="4.2.20 COM_LONG_DATA 消息报文"></a>4.2.20 COM_LONG_DATA 消息报文</h4><p>该消息报文有两种形式，一种用于发送二进制数据，另一种用于发送文本数据。</p><p><strong>功能</strong>：用于发送二进制（BLOB）类型的数据（调用<code>mysql_stmt_send_long_data</code>函数）。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr><tr><td>2</td><td>参数序号（小字节序）</td></tr><tr><td>n</td><td>数据负载（数据到达消息尾部时结束，无结束符）</td></tr></tbody></table><p><strong>功能</strong>：用于发送超长字符串类型的数据（调用<code>mysql_send_long_data</code>函数）</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr><tr><td>2</td><td>参数序号（小字节序）</td></tr><tr><td>2</td><td>数据类型（未使用）</td></tr><tr><td>n</td><td>数据负载（数据到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-21-COM-CLOSE-STMT-消息报文"><a href="#4-2-21-COM-CLOSE-STMT-消息报文" class="headerlink" title="4.2.21 COM_CLOSE_STMT 消息报文"></a>4.2.21 COM_CLOSE_STMT 消息报文</h4><p><strong>功能</strong>：销毁预处理语句。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr></tbody></table><h4 id="4-2-22-COM-RESET-STMT-消息报文"><a href="#4-2-22-COM-RESET-STMT-消息报文" class="headerlink" title="4.2.22 COM_RESET_STMT 消息报文"></a>4.2.22 COM_RESET_STMT 消息报文</h4><p><strong>功能</strong>：将预处理语句的参数缓存清空。多数情况和<code>COM_LONG_DATA</code>一起使用。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr></tbody></table><h4 id="4-2-23-COM-SET-OPTION-消息报文"><a href="#4-2-23-COM-SET-OPTION-消息报文" class="headerlink" title="4.2.23 COM_SET_OPTION 消息报文"></a>4.2.23 COM_SET_OPTION 消息报文</h4><p><strong>功能</strong>：设置语句选项，选项值为<code>/include/mysql_com.h</code>头文件中定义的<code>enum_mysql_set_option</code>枚举类型：</p><ul><li>MYSQL_OPTION_MULTI_STATEMENTS_ON</li><li>MYSQL_OPTION_MULTI_STATEMENTS_OFF</li></ul><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>选项值（小字节序）</td></tr></tbody></table><h4 id="4-2-24-COM-FETCH-STMT-消息报文"><a href="#4-2-24-COM-FETCH-STMT-消息报文" class="headerlink" title="4.2.24 COM_FETCH_STMT 消息报文"></a>4.2.24 COM_FETCH_STMT 消息报文</h4><p><strong>功能</strong>：获取预处理语句的执行结果（一次可以获取多行数据）。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr><tr><td>4</td><td>数据的行数（小字节序）</td></tr></tbody></table><h3 id="4-3-服务器响应报文（服务器-gt-客户端）"><a href="#4-3-服务器响应报文（服务器-gt-客户端）" class="headerlink" title="4.3 服务器响应报文（服务器 -&gt; 客户端）"></a>4.3 服务器响应报文（服务器 -&gt; 客户端）</h3><p>当客户端发起认证请求或命令请求后，服务器会返回相应的执行结果给客户端。客户端在收到响应报文后，需要首先检查第1个字节的值，来区分响应报文的类型。</p><table><thead><tr><th>响应报文类型</th><th>第1个字节取值范围</th></tr></thead><tbody><tr><td>OK 响应报文</td><td>0x00</td></tr><tr><td>Error 响应报文</td><td>0xFF</td></tr><tr><td>Result Set 报文</td><td>0x01 - 0xFA</td></tr><tr><td>Field 报文</td><td>0x01 - 0xFA</td></tr><tr><td>Row Data 报文</td><td>0x01 - 0xFA</td></tr><tr><td>EOF 报文</td><td>0xFE</td></tr></tbody></table><p>注：响应报文的第1个字节在不同类型中含义不同，比如在OK报文中，该字节并没有实际意义，值恒为0x00；而在Result Set报文中，该字节又是长度编码的二进制数据结构（Length Coded Binary）中的第1字节。</p><h4 id="4-3-1-OK-响应报文"><a href="#4-3-1-OK-响应报文" class="headerlink" title="4.3.1 OK 响应报文"></a>4.3.1 OK 响应报文</h4><p>客户端的命令执行正确时，服务器会返回OK响应报文。</p><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>OK报文，值恒为0x00</td></tr><tr><td>1-9</td><td>受影响行数（Length Coded Binary）</td></tr><tr><td>1-9</td><td>索引ID值（Length Coded Binary）</td></tr><tr><td>2</td><td>服务器状态</td></tr><tr><td>n</td><td>服务器消息（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>OK报文，值恒为0x00</td></tr><tr><td>1-9</td><td>受影响行数（Length Coded Binary）</td></tr><tr><td>1-9</td><td>索引ID值（Length Coded Binary）</td></tr><tr><td>2</td><td>服务器状态</td></tr><tr><td>2</td><td>告警计数</td></tr><tr><td>n</td><td>服务器消息（字符串到达消息尾部时结束，无结束符，可选）</td></tr></tbody></table><p><strong>受影响行数</strong>：当执行<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>语句时所影响的数据行数。</p><p><strong>索引ID值</strong>：该值为<code>AUTO_INCREMENT</code>索引字段生成，如果没有索引字段，则为0x00。注意：当<code>INSERT</code>插入语句为多行数据时，该索引ID值为第一个插入的数据行索引值，而非最后一个。</p><p><strong>服务器状态</strong>：客户端可以通过该值检查命令是否在事务处理中。</p><p><strong>告警计数</strong>：告警发生的次数。</p><p><strong>服务器消息</strong>：服务器返回给客户端的消息，一般为简单的描述性字符串，可选字段。</p><h4 id="4-3-2-Error-响应报文"><a href="#4-3-2-Error-响应报文" class="headerlink" title="4.3.2 Error 响应报文"></a>4.3.2 Error 响应报文</h4><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Error报文，值恒为0xFF</td></tr><tr><td>2</td><td>错误编号（小字节序）</td></tr><tr><td>n</td><td>服务器消息</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Error报文，值恒为0xFF</td></tr><tr><td>2</td><td>错误编号（小字节序）</td></tr><tr><td>1</td><td>服务器状态标志，恒为’#’字符</td></tr><tr><td>5</td><td>服务器状态（5个字符）</td></tr><tr><td>n</td><td>服务器消息</td></tr></tbody></table><p><strong>错误编号</strong>：错误编号值定义在源代码<code>/include/mysqld_error.h</code>头文件中。</p><p><strong>服务器状态</strong>：服务器将错误编号通过<code>mysql_errno_to_sqlstate</code>函数转换为状态值，状态值由5字节的ASCII字符组成，定义在源代码<code>/include/sql_state.h</code>头文件中。</p><p><strong>服务器消息</strong>：错误消息字符串到达消息尾时结束，长度可以由消息头中的长度值计算得出。消息长度为0-512字节。</p><h4 id="4-3-3-Result-Set-消息"><a href="#4-3-3-Result-Set-消息" class="headerlink" title="4.3.3 Result Set 消息"></a>4.3.3 Result Set 消息</h4><p>当客户端发送查询请求后，在没有错误的情况下，服务器会返回结果集（Result Set）给客户端。</p><p>Result Set 消息分为五部分，结构如下：</p><table><thead><tr><th>结构</th><th>说明</th></tr></thead><tbody><tr><td>[Result Set Header]</td><td>列数量</td></tr><tr><td>[Field]</td><td>列信息（多个）</td></tr><tr><td>[EOF]</td><td>列结束</td></tr><tr><td>[Row Data]</td><td>行数据（多个）</td></tr><tr><td>[EOF]</td><td>数据结束</td></tr></tbody></table><h4 id="4-3-4-Result-Set-Header-结构"><a href="#4-3-4-Result-Set-Header-结构" class="headerlink" title="4.3.4 Result Set Header 结构"></a>4.3.4 Result Set Header 结构</h4><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1-9</td><td>Field结构计数（Length Coded Binary）</td></tr><tr><td>1-9</td><td>额外信息（Length Coded Binary）</td></tr></tbody></table><p><strong>Field结构计数</strong>：用于标识Field结构的数量，取值范围0x00-0xFA。</p><p><strong>额外信息</strong>：可选字段，一般情况下不应该出现。只有像<code>SHOW COLUMNS</code>这种语句的执行结果才会用到额外信息（标识表格的列数量）。</p><h4 id="4-3-5-Field-结构"><a href="#4-3-5-Field-结构" class="headerlink" title="4.3.5 Field 结构"></a>4.3.5 Field 结构</h4><p>Field为数据表的列信息，在Result Set中，Field会连续出现多次，次数由Result Set Header结构中的IField结构计数值决定。</p><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据表名称（Length Coded String）</td></tr><tr><td>n</td><td>列（字段）名称（Length Coded String）</td></tr><tr><td>4</td><td>列（字段）长度（Length Coded String）</td></tr><tr><td>2</td><td>列（字段）类型（Length Coded String）</td></tr><tr><td>2</td><td>列（字段）标志（Length Coded String）</td></tr><tr><td>1</td><td>整型值精度</td></tr><tr><td>n</td><td>默认值（Length Coded String）</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>目录名称（Length Coded String）</td></tr><tr><td>n</td><td>数据库名称（Length Coded String）</td></tr><tr><td>n</td><td>数据表名称（Length Coded String）</td></tr><tr><td>n</td><td>数据表原始名称（Length Coded String）</td></tr><tr><td>n</td><td>列（字段）名称（Length Coded String）</td></tr><tr><td>4</td><td>列（字段）原始名称（Length Coded String）</td></tr><tr><td>1</td><td>填充值</td></tr><tr><td>2</td><td>字符编码</td></tr><tr><td>4</td><td>列（字段）长度</td></tr><tr><td>1</td><td>列（字段）类型</td></tr><tr><td>2</td><td>列（字段）标志</td></tr><tr><td>1</td><td>整型值精度</td></tr><tr><td>2</td><td>填充值（0x00）</td></tr><tr><td>n</td><td>默认值（Length Coded String）</td></tr></tbody></table><p><strong>目录名称</strong>：在4.1及之后的版本中，该字段值为”def”。</p><p><strong>数据库名称</strong>：数据库名称标识。</p><p><strong>数据表名称</strong>：数据表的别名（<code>AS</code>之后的名称）。</p><p><strong>数据表原始名称</strong>：数据表的原始名称（<code>AS</code>之前的名称）。</p><p><strong>列（字段）名称</strong>：列（字段）的别名（<code>AS</code>之后的名称）。</p><p><strong>列（字段）原始名称</strong>：列（字段）的原始名称（<code>AS</code>之前的名称）。</p><p><strong>字符编码</strong>：列（字段）的字符编码值。</p><p><strong>列（字段）长度</strong>：列（字段）的长度值，真实长度可能小于该值，例如<code>VARCHAR(2)</code>类型的字段实际只能存储1个字符。</p><p><strong>列（字段）类型</strong>：列（字段）的类型值，取值范围如下（参考源代码<code>/include/mysql_com.h</code>头文件中的<code>enum_field_type</code>枚举类型定义）：</p><table><thead><tr><th>类型值</th><th>名称</th></tr></thead><tbody><tr><td>0x00</td><td>FIELD_TYPE_DECIMAL</td></tr><tr><td>0x01</td><td>FIELD_TYPE_TINY</td></tr><tr><td>0x02</td><td>FIELD_TYPE_SHORT</td></tr><tr><td>0x03</td><td>FIELD_TYPE_LONG</td></tr><tr><td>0x04</td><td>FIELD_TYPE_FLOAT</td></tr><tr><td>0x05</td><td>FIELD_TYPE_DOUBLE</td></tr><tr><td>0x06</td><td>FIELD_TYPE_NULL</td></tr><tr><td>0x07</td><td>FIELD_TYPE_TIMESTAMP</td></tr><tr><td>0x08</td><td>FIELD_TYPE_LONGLONG</td></tr><tr><td>0x09</td><td>FIELD_TYPE_INT24</td></tr><tr><td>0x0A</td><td>FIELD_TYPE_DATE</td></tr><tr><td>0x0B</td><td>FIELD_TYPE_TIME</td></tr><tr><td>0x0C</td><td>FIELD_TYPE_DATETIME</td></tr><tr><td>0x0D</td><td>FIELD_TYPE_YEAR</td></tr><tr><td>0x0E</td><td>FIELD_TYPE_NEWDATE</td></tr><tr><td>0x0F</td><td>FIELD_TYPE_VARCHAR (new in MySQL 5.0)</td></tr><tr><td>0x10</td><td>FIELD_TYPE_BIT (new in MySQL 5.0)</td></tr><tr><td>0xF6</td><td>FIELD_TYPE_NEWDECIMAL (new in MYSQL 5.0)</td></tr><tr><td>0xF7</td><td>FIELD_TYPE_ENUM</td></tr><tr><td>0xF8</td><td>FIELD_TYPE_SET</td></tr><tr><td>0xF9</td><td>FIELD_TYPE_TINY_BLOB</td></tr><tr><td>0xFA</td><td>FIELD_TYPE_MEDIUM_BLOB</td></tr><tr><td>0xFB</td><td>FIELD_TYPE_LONG_BLOB</td></tr><tr><td>0xFC</td><td>FIELD_TYPE_BLOB</td></tr><tr><td>0xFD</td><td>FIELD_TYPE_VAR_STRING</td></tr><tr><td>0xFE</td><td>FIELD_TYPE_STRING</td></tr><tr><td>0xFF</td><td>FIELD_TYPE_GEOMETRY</td></tr></tbody></table><p><strong>列（字段）标志</strong>：各标志位定义如下（参考源代码<code>/include/mysql_com.h</code>头文件中的宏定义）：</p><table><thead><tr><th>标志位</th><th>名称</th></tr></thead><tbody><tr><td>0x0001</td><td>NOT_NULL_FLAG</td></tr><tr><td>0x0002</td><td>PRI_KEY_FLAG</td></tr><tr><td>0x0004</td><td>UNIQUE_KEY_FLAG</td></tr><tr><td>0x0008</td><td>MULTIPLE_KEY_FLAG</td></tr><tr><td>0x0010</td><td>BLOB_FLAG</td></tr><tr><td>0x0020</td><td>UNSIGNED_FLAG</td></tr><tr><td>0x0040</td><td>ZEROFILL_FLAG</td></tr><tr><td>0x0080</td><td>BINARY_FLAG</td></tr><tr><td>0x0100</td><td>ENUM_FLAG</td></tr><tr><td>0x0200</td><td>AUTO_INCREMENT_FLAG</td></tr><tr><td>0x0400</td><td>TIMESTAMP_FLAG</td></tr><tr><td>0x0800</td><td>SET_FLAG</td></tr></tbody></table><p><strong>数值精度</strong>：该字段对<code>DECIMAL</code>和<code>NUMERIC</code>类型的数值字段有效，用于标识数值的精度（小数点位置）。</p><p><strong>默认值</strong>：该字段用在数据表定义中，普通的查询结果中不会出现。</p><p><strong>附</strong>：Field结构的相关处理函数：</p><ul><li>客户端：<code>/client/client.c</code>源文件中的<code>unpack_fields</code>函数</li><li>服务器：<code>/sql/sql_base.cc</code>源文件中的<code>send_fields</code>函数</li></ul><h4 id="4-3-6-EOF-结构"><a href="#4-3-6-EOF-结构" class="headerlink" title="4.3.6 EOF 结构"></a>4.3.6 EOF 结构</h4><p>EOF结构用于标识Field和Row Data的结束，在预处理语句中，EOF也被用来标识参数的结束。</p><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>EOF值（0xFE）</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>EOF值（0xFE）</td></tr><tr><td>2</td><td>告警计数</td></tr><tr><td>2</td><td>状态标志位</td></tr></tbody></table><p><strong>告警计数</strong>：服务器告警数量，在所有数据都发送给客户端后该值才有效。</p><p><strong>状态标志位</strong>：包含类似<code>SERVER_MORE_RESULTS_EXISTS</code>这样的标志位。</p><p><strong>注</strong>：由于EOF值与其它Result Set结构共用1字节，所以在收到报文后需要对EOF包的真实性进行校验，校验条件为：</p><ul><li>第1字节值为0xFE</li><li>包长度小于9字节</li></ul><p><strong>附</strong>：EOF结构的相关处理函数：</p><ul><li>服务器：<code>protocol.cc</code>源文件中的<code>send_eof</code>函数</li></ul><h4 id="4-3-7-Row-Data-结构"><a href="#4-3-7-Row-Data-结构" class="headerlink" title="4.3.7 Row Data 结构"></a>4.3.7 Row Data 结构</h4><p>在Result Set消息中，会包含多个Row Data结构，每个Row Data结构又包含多个字段值，这些字段值组成一行数据。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>字段值（Length Coded String）</td></tr><tr><td>…</td><td>（一行数据中包含多个字段值）</td></tr></tbody></table><p><strong>字段值</strong>：行数据中的字段值，字符串形式。</p><p><strong>附</strong>：Row Data结构的相关处理函数：</p><ul><li>客户端：<code>/client/client.c</code>源文件中的<code>read_rows</code>函数</li></ul><h4 id="4-3-8-Row-Data-结构（二进制数据）"><a href="#4-3-8-Row-Data-结构（二进制数据）" class="headerlink" title="4.3.8 Row Data 结构（二进制数据）"></a>4.3.8 Row Data 结构（二进制数据）</h4><p>该结构用于传输二进制的字段值，既可以是服务器返回的结果，也可以是由客户端发送的（当执行预处理语句时，客户端使用Result Set消息来发送参数及数据）。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>结构头（0x00）</td></tr><tr><td>(列数量 + 7 + 2) / 8</td><td>空位图</td></tr><tr><td>n</td><td>字段值</td></tr><tr><td>…</td><td>（一行数据中包含多个字段值）</td></tr></tbody></table><p><strong>空位图</strong>：前2个比特位被保留，值分别为0和1，以保证不会和OK、Error包的首字节冲突。在MySQL 5.0及之后的版本中，这2个比特位的值都为0。</p><p><strong>字段值</strong>：行数据中的字段值，二进制形式。</p><h4 id="4-3-9-PREPARE-OK-响应报文（Prepared-Statement）"><a href="#4-3-9-PREPARE-OK-响应报文（Prepared-Statement）" class="headerlink" title="4.3.9 PREPARE_OK 响应报文（Prepared Statement）"></a>4.3.9 PREPARE_OK 响应报文（Prepared Statement）</h4><p>用于响应客户端发起的预处理语句报文，组成结构如下：</p><table><thead><tr><th>结构</th><th>说明</th></tr></thead><tbody><tr><td>[PREPARE_OK]</td><td>PREPARE_OK结构</td></tr><tr><td>如果参数数量大于0</td><td></td></tr><tr><td>[Field]</td><td>与Result Set消息结构相同</td></tr><tr><td>[EOF]</td><td></td></tr><tr><td>如果列数大于0</td><td></td></tr><tr><td>[Field]</td><td>与Result Set消息结构相同</td></tr><tr><td>[EOF]</td></tr></tbody></table><p>其中 PREPARD_OK 的结构如下：</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>OK报文，值为0x00</td></tr><tr><td>4</td><td>预处理语句ID值</td></tr><tr><td>2</td><td>列数量</td></tr><tr><td>2</td><td>参数数量</td></tr><tr><td>1</td><td>填充值（0x00）</td></tr><tr><td>2</td><td>告警计数</td></tr></tbody></table><h4 id="4-3-10-Parameter-响应报文（Prepared-Statement）"><a href="#4-3-10-Parameter-响应报文（Prepared-Statement）" class="headerlink" title="4.3.10 Parameter 响应报文（Prepared Statement）"></a>4.3.10 Parameter 响应报文（Prepared Statement）</h4><p>预处理语句的值与参数正确对应后，服务器会返回 Parameter 报文。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>类型</td></tr><tr><td>2</td><td>标志</td></tr><tr><td>1</td><td>数值精度</td></tr><tr><td>4</td><td>字段长度</td></tr></tbody></table><p><strong>类型</strong>：与 Field 结构中的字段类型相同。</p><p><strong>标志</strong>：与 Field 结构中的字段标志相同。</p><p><strong>数值精度</strong>：与 Field 结构中的数值精度相同。</p><p><strong>字段长度</strong>：与 Field 结构中的字段长度相同。</p><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h2><p>《<a href="http://dev.mysql.com/doc/internals/en/index.html" target="_blank" rel="noopener">MySQL Internals Manual</a>: <a href="http://dev.mysql.com/doc/internals/en/client-server-protocol.html" target="_blank" rel="noopener">MySQL Client/Server Protocol</a>》</p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/" target="_blank" rel="noopener">http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-交互过程&quot;&gt;&lt;a href=&quot;#1-交互过程&quot; class=&quot;headerlink&quot; title=&quot;1 交互过程&quot;&gt;&lt;/a&gt;1 交互过程&lt;/h2&gt;&lt;p&gt;MySQL客户端与服务器的交互主要分为两个阶段：握手认证阶段和命令执行阶段。&lt;/p&gt;
&lt;h3 id=&quot;1-1-握手认证阶段&quot;&gt;&lt;a href=&quot;#1-1-握手认证阶段&quot; class=&quot;headerlink&quot; title=&quot;1.1 握手认证阶段&quot;&gt;&lt;/a&gt;1.1 握手认证阶段&lt;/h3&gt;&lt;p&gt;握手认证阶段为客户端与服务器建立连接后进行，交互过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：握手初始化消息&lt;/li&gt;
&lt;li&gt;客户端 -&amp;gt; 服务器：登陆认证消息&lt;/li&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：认证结果消息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-命令执行阶段&quot;&gt;&lt;a href=&quot;#1-2-命令执行阶段&quot; class=&quot;headerlink&quot; title=&quot;1.2 命令执行阶段&quot;&gt;&lt;/a&gt;1.2 命令执行阶段&lt;/h3&gt;&lt;p&gt;客户端认证成功后，会进入命令执行阶段，交互过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端 -&amp;gt; 服务器：执行命令消息&lt;/li&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：命令执行结果&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>[整理]MySQL查看连接数以及状态</title>
    <link href="http://www.twosee.cn/2018/05/12/mysql-status-check/"/>
    <id>http://www.twosee.cn/2018/05/12/mysql-status-check/</id>
    <published>2018-05-12T03:05:53.000Z</published>
    <updated>2018-05-12T03:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h2><p><strong>命令：<code>show processlist;</code></strong><br><strong>如果是root帐号，你能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。</strong><br><code>show processlist</code>只列出前100条</p><p>如果想全列出请使用<strong><code>show full processlist;</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br></pre></td></tr></table></figure><h2 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h2><p><strong>命令： <code>show status;</code></strong></p><p><strong>命令：<code>show status like &#39;%下面变量%&#39;;</code></strong></p><a id="more"></a><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>Aborted_clients</td><td>由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。</td></tr><tr><td>Aborted_connects</td><td>尝试已经失败的MySQL服务器的连接的次数。</td></tr><tr><td>Connections</td><td>试图连接MySQL服务器的次数。</td></tr><tr><td>Created_tmp_tables</td><td>当执行语句时，已经被创造了的隐含临时表的数量。</td></tr><tr><td>Delayed_insert_threads</td><td>正在使用的延迟插入处理器线程的数量。</td></tr><tr><td>Delayed_writes</td><td>用INSERT/DELAYED写入的行数。</td></tr><tr><td>Delayed_errors</td><td>用INSERT/DELAYED写入的发生某些错误(可能重复键值)的行数。</td></tr><tr><td>Flush_commands</td><td>执行FLUSH命令的次数。</td></tr><tr><td>Handler_delete</td><td>请求从一张表中删除行的次数。</td></tr><tr><td>Handler_read_first</td><td>请求读入表中第一行的次数。</td></tr><tr><td>Handler_read_key</td><td>请求数字基于键读行。</td></tr><tr><td>Handler_read_next</td><td>请求读入基于一个键的一行的次数。</td></tr><tr><td>Handler_read_rnd</td><td>请求读入基于一个固定位置的一行的次数。</td></tr><tr><td>Handler_update</td><td>请求更新表中一行的次数。</td></tr><tr><td>Handler_write</td><td>请求向表中插入一行的次数。</td></tr><tr><td>Key_blocks_used</td><td>用于关键字缓存的块的数量。</td></tr><tr><td>Key_read_requests</td><td>请求从缓存读入一个键值的次数。</td></tr><tr><td>Key_reads</td><td>从磁盘物理读入一个键值的次数。</td></tr><tr><td>Key_write_requests</td><td>请求将一个关键字块写入缓存次数。</td></tr><tr><td>Key_writes</td><td>将一个键值块物理写入磁盘的次数。</td></tr><tr><td>Max_used_connections</td><td>同时使用的连接的最大数目。</td></tr><tr><td>Not_flushed_key_blocks</td><td>在键缓存中已经改变但是还没被清空到磁盘上的键块。</td></tr><tr><td>Not_flushed_delayed_rows</td><td>在INSERT/DELAY队列中等待写入的行的数量。</td></tr><tr><td>Open_tables</td><td>打开表的数量。</td></tr><tr><td>Open_files</td><td>打开文件的数量。</td></tr><tr><td>Open_streams</td><td>打开流的数量(主要用于日志记载）</td></tr><tr><td>Opened_tables</td><td>已经打开的表的数量。</td></tr><tr><td>Questions</td><td>发往服务器的查询的数量。</td></tr><tr><td>Slow_queries</td><td>要花超过long_query_time时间的查询数量。</td></tr><tr><td>Threads_connected</td><td>当前打开的连接的数量。</td></tr><tr><td>Threads_running</td><td>不在睡眠的线程数量。</td></tr><tr><td>Uptime</td><td>服务器工作了多少秒。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Connections&quot;&gt;&lt;a href=&quot;#Connections&quot; class=&quot;headerlink&quot; title=&quot;Connections&quot;&gt;&lt;/a&gt;Connections&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;show processlist;&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;如果是root帐号，你能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。&lt;/strong&gt;&lt;br&gt;&lt;code&gt;show processlist&lt;/code&gt;只列出前100条&lt;/p&gt;
&lt;p&gt;如果想全列出请使用&lt;strong&gt;&lt;code&gt;show full processlist;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; show processlist;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Status&quot;&gt;&lt;a href=&quot;#Status&quot; class=&quot;headerlink&quot; title=&quot;Status&quot;&gt;&lt;/a&gt;Status&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命令： &lt;code&gt;show status;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;show status like &amp;#39;%下面变量%&amp;#39;;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Swoole的Mysql模块浅析-1</title>
    <link href="http://www.twosee.cn/2018/05/11/swoole-mysql-analyzation-1/"/>
    <id>http://www.twosee.cn/2018/05/11/swoole-mysql-analyzation-1/</id>
    <published>2018-05-11T12:48:00.000Z</published>
    <updated>2018-05-12T03:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知, PHP是由C语言编写的, 扩展也不例外, Swoole又是PHP扩展中发展的比较快且很权威的一个扩展, 对于MySQL这部分模块的浅析, 暂可不必了解Swoole底层的实现, 而先关注应用层面的实现.</p><h2 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h2><p>所以除了PHP我们仅需了解以下几个方面的知识:</p><ol><li>MySQL基础</li><li>TCP网络协议基础(MySQL协议)</li><li>C语言基础及其简单调试</li></ol><p>而使用过Swoole的同学一定对以下工具不陌生:</p><ol><li><code>GDB</code>(Mac下用<code>LLDB</code>)和<code>Valgrind</code>作为源码/内存分析</li><li><code>Wireshark</code>或<code>TcpDump</code>作为网络分析</li></ol><a id="more"></a><h2 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h2><p>首先我们写一个简单的协程Mysql查询Demo</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">go(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $db = <span class="keyword">new</span> Swoole\Coroutine\Mysql;</span><br><span class="line">    $server = [</span><br><span class="line">        <span class="string">'host'</span>     =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'user'</span>     =&gt; <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'password'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'database'</span> =&gt; <span class="string">'test'</span></span><br><span class="line">    ];</span><br><span class="line">    $db-&gt;connect($server);</span><br><span class="line">    $stmt = $db-&gt;prepare(<span class="string">'SELECT * FROM `userinfo`'</span>);</span><br><span class="line">    $ret = $stmt-&gt;execute([]);</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们可以使用Wireshark对本地网络进行捕获<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fr7pj4z2djj30rs0m8jtr.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>依托于功能强大的wireshark, 我们只需过滤器里输入<code>mysql</code>即可从繁忙的本地网络中筛选出mysql通信的数据</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fr7ptebaaej30rk06x409.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们可以看到MySQL通信<strong>建立后</strong>的部分(不包括前面TCP握手等部分)</p><ol><li>Mysql服务器向客户端打招呼, 并携带了自身版本信息</li><li>客户端收到后, 发起登录请求, 并携带了配置参数(用户名/密码/使用编码/选择进入的数据库等)</li><li>Mysql响应登录成功</li><li>发出一个携带SQL语句的PREPARE请求来编译模板语句 [COM_STMT_PREPARE]</li><li>Mysql响应PREPARE_OK响应报文 (这里的返回报文比较复杂,在下一篇细讲)</li><li>发出执行指定ID模板语句的请求, 并携带了参数数据  [COM_STMT_EXECUTE]</li><li>Mysql响应结果集(此处也很复杂)</li></ol><h2 id="问题发现-swoole的疏漏"><a href="#问题发现-swoole的疏漏" class="headerlink" title="问题发现: swoole的疏漏?"></a>问题发现: swoole的疏漏?</h2><p>乍看之下这一套流程并没有什么问题, 但由于在此之前我是PDO的忠实粉丝(Swoole的Statement功能也是当初机缘巧合我建议Rango大佬考虑加入的), 所以我在阅读Swoole源码的同时也阅读了PDO源码并编写demo互作比对, 然后很快就发现了问题.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$pdo = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=127.0.0.1;dbname=test;charset=utf8"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, <span class="keyword">false</span>);</span><br><span class="line">$sql = <span class="string">"SELECT * FROM  userinfo WHERE `id`=:id"</span>;</span><br><span class="line">$stmt = $pdo-&gt;prepare($sql);</span><br><span class="line">$res = $stmt-&gt;execute([<span class="string">'id'</span> =&gt; <span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p><h3 id="缺失的流程"><a href="#缺失的流程" class="headerlink" title="缺失的流程"></a>缺失的流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fr7qnai0mxj30rv05egn7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>很容易可以发现, PDO比Swoole多做了一些<strong>善后处理</strong>, 在statement对象销毁时, 触发了destruct主动通知mysql销毁了模板语句, 然后在pdo对象销毁时, 又主动通知了mysql该会话/连接退出.</p><hr><p>马上我怀疑是我没有主动在swoole调用close关闭的缘故, 但是close应该是在destruct的时候自动触发的, 所以我们需要深入一波源码, 看看swoole是否有做收尾工作.</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>直接通过文件名和关键字搜索来查看对应源码也是可以的, 但是用gdb调试来查看底层C内部运作的流程会更酷.</p><p>Mac下使用lldb工具更佳, 操作和gdb大同小异.</p><p>在终端中输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb php "/path/to/swoole-mysql.php"</span><br></pre></td></tr></table></figure><p>就可以在lldb中设置调试程序和对应脚本(实际上是调试PHP这个C程序, 并添加了path作为第一个argument)</p><p>由于Swoole的协程运作机制异常复杂, PHP脚本并不是像代码那样按序从头到尾运行一遍那么简单, go函数会立即返回, Swoole会在脚本结尾注册shutdown-function, 然后进入事件循环, 这里我有空会写一篇新文章分析, 所以按照常规方式操作并不能分析该脚本的调用栈.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> b = breakpoint; r = run</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ==================</span></span><br><span class="line">b "zim_swoole_mysql_coro___destruct"</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p>此时可能会提示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1: no locations (pending).</span><br><span class="line">WARNING:  Unable to resolve breakpoint to any actual locations.</span><br></pre></td></tr></table></figure><br>实际上是可以下断点的, 只是由于某些的缘故lldb找不到该位置, 有待分析</p><p>然后你就可以看到程序运行了并断在了这里, 你可以输入<code>list</code>来展开源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x00000001038aace3</span> swoole.so`zim_swoole_mysql_coro___destruct(execute_data=<span class="number">0x0000000101c85210</span>, return_value=<span class="number">0x00007ffeefbfd998</span>) at swoole_mysql_coro.c:<span class="number">1088</span></span><br><span class="line">   <span class="number">1085</span></span><br><span class="line">   <span class="number">1086</span><span class="function"><span class="keyword">static</span> <span class="title">PHP_METHOD</span><span class="params">(swoole_mysql_coro, __destruct)</span></span></span><br><span class="line"><span class="function">   1087</span>&#123;</span><br><span class="line">-&gt; <span class="number">1088</span>    mysql_client *client = swoole_get_object(getThis());</span><br><span class="line">   <span class="number">1089</span>    <span class="keyword">if</span> (!client)</span><br><span class="line">   <span class="number">1090</span>    &#123;</span><br><span class="line">   <span class="number">1091</span>        <span class="keyword">return</span>;</span><br><span class="line">Target <span class="number">0</span>: (php) stopped.</span><br><span class="line">(lldb) <span class="built_in">list</span></span><br><span class="line">   <span class="number">1092</span>    &#125;</span><br><span class="line">   <span class="number">1093</span>    <span class="keyword">if</span> (client-&gt;state != SW_MYSQL_STATE_CLOSED &amp;&amp; client-&gt;cli)</span><br><span class="line">   <span class="number">1094</span>    &#123;</span><br><span class="line">   <span class="number">1095</span>        swoole_mysql_coro_close(getThis());</span><br><span class="line">   <span class="number">1096</span>    &#125;</span><br><span class="line">   <span class="number">1097</span>    <span class="keyword">if</span> (client-&gt;<span class="built_in">buffer</span>)</span><br><span class="line">   <span class="number">1098</span>    &#123;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1099</span>        swString_free(client-&gt;<span class="built_in">buffer</span>);</span><br><span class="line">   <span class="number">1100</span>    &#125;</span><br><span class="line">   <span class="number">1101</span>    efree(client);</span><br><span class="line">   <span class="number">1102</span>    swoole_set_object(getThis(), <span class="literal">NULL</span>);</span><br><span class="line">   <span class="number">1103</span></span><br><span class="line">   <span class="number">1104</span>    php_context *context = swoole_get_property(getThis(), <span class="number">0</span>);</span><br><span class="line">   <span class="number">1105</span>    <span class="keyword">if</span> (!context)</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1106</span>    &#123;</span><br><span class="line">   <span class="number">1107</span>        <span class="keyword">return</span>;</span><br><span class="line">   <span class="number">1108</span>    &#125;</span><br><span class="line">   <span class="number">1109</span>    <span class="keyword">if</span> (likely(context-&gt;state == SW_CORO_CONTEXT_RUNNING))</span><br><span class="line">   <span class="number">1110</span>    &#123;</span><br><span class="line">   <span class="number">1111</span>        efree(context);</span><br><span class="line">   <span class="number">1112</span>    &#125;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1113</span>    <span class="keyword">else</span></span><br><span class="line">   <span class="number">1114</span>    &#123;</span><br><span class="line">   <span class="number">1115</span>        context-&gt;state = SW_CORO_CONTEXT_TERM;</span><br><span class="line">   <span class="number">1116</span>    &#125;</span><br><span class="line">   <span class="number">1117</span>    swoole_set_property(getThis(), <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="number">1118</span>&#125;</span><br><span class="line">   <span class="number">1119</span></span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1120</span><span class="function"><span class="keyword">static</span> <span class="title">PHP_METHOD</span><span class="params">(swoole_mysql_coro, <span class="built_in">close</span>)</span></span></span><br><span class="line"><span class="function">   1121</span>&#123;</span><br><span class="line">   <span class="number">1122</span>    <span class="keyword">if</span> (swoole_mysql_coro_close(getThis()) == FAILURE)</span><br><span class="line">   <span class="number">1123</span>    &#123;</span><br><span class="line">   <span class="number">1124</span>        RETURN_FALSE;</span><br><span class="line">   <span class="number">1125</span>    &#125;</span><br><span class="line">   <span class="number">1126</span><span class="meta">#<span class="meta-keyword">if</span> PHP_MAJOR_VERSION &lt; 7</span></span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1127</span>    sw_zval_ptr_dtor(&amp;getThis());</span><br><span class="line">   <span class="number">1128</span><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="number">1129</span>RETURN_TRUE;</span><br><span class="line">   <span class="number">1130</span>&#125;</span><br></pre></td></tr></table></figure><p>在析构函数中的1095行, 和close函数中的1122行, 我们都可以看到调用了swoole_mysql_coro_close方法, 再次下断点调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x00000001030ae573</span> swoole.so`swoole_mysql_coro_close(<span class="keyword">this</span>=<span class="number">0x0000000101c85230</span>) at swoole_mysql_coro.c:<span class="number">180</span></span><br><span class="line">   <span class="number">177</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swoole_mysql_coro_close</span><span class="params">(zval *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function">   178 </span>&#123;</span><br><span class="line">   <span class="number">179</span>     SWOOLE_GET_TSRMLS;</span><br><span class="line">-&gt; <span class="number">180</span>     mysql_client *client = swoole_get_object(<span class="keyword">this</span>);</span><br><span class="line">   <span class="number">181</span>     <span class="keyword">if</span> (!client)</span><br><span class="line">   <span class="number">182</span>     &#123;</span><br><span class="line">   <span class="number">183</span>         swoole_php_fatal_error(E_WARNING, <span class="string">"object is not instanceof swoole_mysql_coro."</span>);</span><br><span class="line">Target <span class="number">0</span>: (php) stopped.</span><br><span class="line">(lldb) l</span><br><span class="line">   <span class="number">184</span>         <span class="keyword">return</span> FAILURE;</span><br><span class="line">   <span class="number">185</span>     &#125;</span><br><span class="line">   <span class="number">186</span></span><br><span class="line">   <span class="number">187</span>     <span class="keyword">if</span> (!client-&gt;cli)</span><br><span class="line">   <span class="number">188</span>     &#123;</span><br><span class="line">   <span class="number">189</span>         <span class="keyword">return</span> FAILURE;</span><br><span class="line">   <span class="number">190</span>     &#125;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">191</span></span><br><span class="line">   <span class="number">192</span>     zend_update_property_bool(swoole_mysql_coro_class_entry_ptr, <span class="keyword">this</span>, ZEND_STRL(<span class="string">"connected"</span>), <span class="number">0</span> TSRMLS_CC);</span><br><span class="line">   <span class="number">193</span>     SwooleG.main_reactor-&gt;del(SwooleG.main_reactor, client-&gt;fd);</span><br><span class="line">   <span class="number">194</span></span><br><span class="line">   <span class="number">195</span>     swConnection *_socket = swReactor_get(SwooleG.main_reactor, client-&gt;fd);</span><br><span class="line">   <span class="number">196</span>     _socket-&gt;object = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="number">197</span>     _socket-&gt;active = <span class="number">0</span>;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">198</span></span><br><span class="line">   <span class="number">199</span>     <span class="keyword">if</span> (client-&gt;timer)</span><br><span class="line">   <span class="number">200</span>     &#123;</span><br><span class="line">   <span class="number">201</span>         swTimer_del(&amp;SwooleG.timer, client-&gt;timer);</span><br><span class="line">   <span class="number">202</span>         client-&gt;timer = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="number">203</span>     &#125;</span><br><span class="line">   <span class="number">204</span></span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">205</span>     <span class="keyword">if</span> (client-&gt;statement_list)</span><br><span class="line">   <span class="number">206</span>     &#123;</span><br><span class="line">   <span class="number">207</span>         swLinkedList_node *node = client-&gt;statement_list-&gt;head;</span><br><span class="line">   <span class="number">208</span>         <span class="keyword">while</span> (node)</span><br><span class="line">   <span class="number">209</span>         &#123;</span><br><span class="line">   <span class="number">210</span>             mysql_statement *stmt = node-&gt;data;</span><br><span class="line">   <span class="number">211</span>             <span class="keyword">if</span> (stmt-&gt;object)</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">212</span>             &#123;</span><br><span class="line">   <span class="number">213</span>                 swoole_set_object(stmt-&gt;object, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="number">214</span>                 efree(stmt-&gt;object);</span><br><span class="line">   <span class="number">215</span>             &#125;</span><br><span class="line">   <span class="number">216</span>             efree(stmt);</span><br><span class="line">   <span class="number">217</span>             node = node-&gt;next;</span><br><span class="line">   <span class="number">218</span>         &#125;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">219</span>         swLinkedList_free(client-&gt;statement_list);</span><br><span class="line">   <span class="number">220</span>     &#125;</span><br><span class="line">   <span class="number">221</span></span><br><span class="line">   <span class="number">222</span>     client-&gt;cli-&gt;<span class="built_in">close</span>(client-&gt;cli);</span><br><span class="line">   <span class="number">223</span>     swClient_free(client-&gt;cli);</span><br><span class="line">   <span class="number">224</span>     efree(client-&gt;cli);</span><br><span class="line">   <span class="number">225</span>     client-&gt;cli = <span class="literal">NULL</span>;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">226</span>     client-&gt;state = SW_MYSQL_STATE_CLOSED;</span><br><span class="line">   <span class="number">227</span>     client-&gt;iowait = SW_MYSQL_CORO_STATUS_CLOSED;</span><br><span class="line">   <span class="number">228</span></span><br><span class="line">   <span class="number">229</span>     <span class="keyword">return</span> SUCCESS;</span><br><span class="line">   <span class="number">230</span> &#125;</span><br></pre></td></tr></table></figure><p>析构函数中可以看到一系列对自身的”清理操作”, 因为对象要被销毁了.</p><p>而swoole_mysql_coro_close中可以看到一系列”关闭操作”和对该client所持有的statement们的清理操作, statement_list是一个链表, statement的标识ID是依赖于指定会话连接的, 索引ID从1开始, 连接关闭了所以statement必须在这时就销毁.</p><p>而222行的<code>client-&gt;cli-&gt;close(client-&gt;cli)</code>是用swoole的client进行了TCP连接关闭.</p><h2 id="结论和进一步深思"><a href="#结论和进一步深思" class="headerlink" title="结论和进一步深思"></a>结论和进一步深思</h2><p>所以我们可以发现, Swoole只对自己进行了清理, 并且关闭了TCP连接, 而没有在MySQL协议层面进行连接关闭, 这样会不会造成MySQL服务端还长期存在连接, 并没有销毁清理的情况呢?</p><p>首先, 在连接尚未关闭但是statement对象被销毁的时候, swoole并不会通知mysql去销毁语句模板, 所以要是长连接的时候有很多语句在swoole端一次性使用了的话, mysql那边应该会一直保存着那些语句模板, 等待这个连接下一次可能的使用.</p><h3 id="验证-查看未关闭的连接"><a href="#验证-查看未关闭的连接" class="headerlink" title="验证: 查看未关闭的连接"></a>验证: 查看未关闭的连接</h3><p>而swoole端对tcp连接关闭后, mysql端没有收到mysql协议层面的关闭消息, 会不会还傻傻等着呢?</p><p>这时候我们可以运行一下脚本, 然后在mysql端使用<code>show full processlist</code>来查看连接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show full processlist;</span><br><span class="line">+-----+------+-----------------+------+---------+------+----------+-----------------------+</span><br><span class="line">| Id  | User | Host            | db   | Command | Time | State    | Info                  |</span><br><span class="line">+-----+------+-----------------+------+---------+------+----------+-----------------------+</span><br><span class="line">| 151 | root | localhost:58186 | NULL | Query   |    0 | starting | show full processlist |</span><br><span class="line">+-----+------+-----------------+------+---------+------+----------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>Woo! 除了我们当前连接居然没有其他连接了, 说明MySQL在TCP连接关闭时就”智能”地清除了会话.</p><h3 id="最后验证-真的没有影响吗"><a href="#最后验证-真的没有影响吗" class="headerlink" title="最后验证: 真的没有影响吗?"></a>最后验证: 真的没有影响吗?</h3><p>我们程序员要有刨根问底精神, 连接强制关闭了, 真的没有副作用吗?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#39;%Abort_%&#39;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Aborted_clients  | 118   |</span><br><span class="line">| Aborted_connects | 0     |</span><br><span class="line">+------------------+-------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。</p><p>Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。 </p></blockquote><p>可以看到, MySQL统计了异常中断的客户端和连接, 在我们近期的使用中, 没有正确关闭连接的客户端有118个</p><p>但是MySQL既然可以统计到该数据, 自然也可以对这些客户端连接进行正常清理, 比较还有一手TCP层面的逻辑在里头, 但是这样粗暴地关闭, 就像我们平时手机杀程序清内存或者强制关机的操作一样, 一般来说无甚危害, <strong>但是万一哪天真的发生了异常, 客户端大量死掉, 我们也很难去发现了.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知, PHP是由C语言编写的, 扩展也不例外, Swoole又是PHP扩展中发展的比较快且很权威的一个扩展, 对于MySQL这部分模块的浅析, 暂可不必了解Swoole底层的实现, 而先关注应用层面的实现.&lt;/p&gt;
&lt;h2 id=&quot;基础要求&quot;&gt;&lt;a href=&quot;#基础要求&quot; class=&quot;headerlink&quot; title=&quot;基础要求&quot;&gt;&lt;/a&gt;基础要求&lt;/h2&gt;&lt;p&gt;所以除了PHP我们仅需了解以下几个方面的知识:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MySQL基础&lt;/li&gt;
&lt;li&gt;TCP网络协议基础(MySQL协议)&lt;/li&gt;
&lt;li&gt;C语言基础及其简单调试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而使用过Swoole的同学一定对以下工具不陌生:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;GDB&lt;/code&gt;(Mac下用&lt;code&gt;LLDB&lt;/code&gt;)和&lt;code&gt;Valgrind&lt;/code&gt;作为源码/内存分析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Wireshark&lt;/code&gt;或&lt;code&gt;TcpDump&lt;/code&gt;作为网络分析&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>why-not-http2</title>
    <link href="http://www.twosee.cn/2018/04/09/why-not-http2/"/>
    <id>http://www.twosee.cn/2018/04/09/why-not-http2/</id>
    <published>2018-04-09T03:07:20.000Z</published>
    <updated>2018-04-09T03:07:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why-not-HTTP2"><a href="#Why-not-HTTP2" class="headerlink" title="Why not HTTP2"></a>Why not HTTP2</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Why-not-HTTP2&quot;&gt;&lt;a href=&quot;#Why-not-HTTP2&quot; class=&quot;headerlink&quot; title=&quot;Why not HTTP2&quot;&gt;&lt;/a&gt;Why not HTTP2&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Http2" scheme="http://www.twosee.cn/tags/Http2/"/>
    
  </entry>
  
  <entry>
    <title>[整理]【位运算经典应用】 标志位与掩码</title>
    <link href="http://www.twosee.cn/2018/04/06/mask-code/"/>
    <id>http://www.twosee.cn/2018/04/06/mask-code/</id>
    <published>2018-04-06T15:03:01.000Z</published>
    <updated>2018-04-06T15:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整理-【位运算经典应用】-标志位与掩码"><a href="#整理-【位运算经典应用】-标志位与掩码" class="headerlink" title="[整理]【位运算经典应用】 标志位与掩码"></a>[整理]【位运算经典应用】 标志位与掩码</h3><blockquote><p>本文原文来源自 <a href="http://www.cnblogs.com/zichi/p/4792589.html" target="_blank" rel="noopener">http://www.cnblogs.com/zichi/p/4792589.html</a></p><p>相关内容经过整理, ABCD几个水果单词更加容易对应起来</p></blockquote><p>前面我们已经了解了六大位操作符（<code>&amp;</code> <code>|</code> <code>~</code> <code>^</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code>)的用法（<a href="http://www.cnblogs.com/zichi/p/4787145.html" target="_blank" rel="noopener">javascript 位运算</a>），也整理了一些常用的位运算操作（<a href="http://www.cnblogs.com/zichi/p/4789439.html" target="_blank" rel="noopener">常用位运算整理</a>），本文我们继续深入位运算，来了解下二进制的经典应用-标志位与掩码。</p><p>位运算经常被用来创建、处理以及读取标志位序列——一种类似二进制的变量。虽然可以使用变量代替标志位序列，但是这样可以节省内存（1/32）。</p><p>例如有4个标志位：</p><ol><li>标志位A： 我们有 Apple</li><li>标志位B： 我们有 Banana</li><li>标志位C： 我们有 Cherry</li><li>标志位D： 我们有 Dew</li></ol><p>标志位通过位序列DCBA来表示，当一个位置被置为1时，表示有该项，置为0时，表示没有该项。例如一个变量flag=9，二进制表示为1001，就表示我们有D和A。</p><p>掩码 (bitmask) 是一个通过与/或来读取标志位的位序列。典型的定义每个标志位的原语掩码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FLAG_A = <span class="number">1</span>; <span class="comment">// 0001</span></span><br><span class="line"><span class="keyword">var</span> FLAG_B = <span class="number">2</span>; <span class="comment">// 0010</span></span><br><span class="line"><span class="keyword">var</span> FLAG_C = <span class="number">4</span>; <span class="comment">// 0100</span></span><br><span class="line"><span class="keyword">var</span> FLAG_D = <span class="number">8</span>; <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>新的掩码可以在以上掩码上使用逻辑运算创建。例如，掩码 1011 可以通过 FLAG_A、FLAG_B 和 FLAG_D 逻辑或得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mask = FLAG_A | FLAG_B | FLAG_D; <span class="comment">// 0001 | 0010 | 1000 =&gt; 1011</span></span><br></pre></td></tr></table></figure><p>某个特定的位可以通过与掩码做逻辑与运算得到，通过与掩码的与运算可以去掉无关的位，得到特定的位。例如，掩码 0100 可以用来检查标志位 C 是否被置位：（<strong>核心就是判断某位上的数</strong> 参考<a href="http://www.cnblogs.com/zichi/p/4789439.html" target="_blank" rel="noopener">常用位运算整理</a> 下同）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们有 Cherry</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FLAG_C) &#123; <span class="comment">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span></span><br><span class="line">   <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个有多个位被置位的掩码表达任一/或者的含义。例如，以下两个表达是等价的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们有 Banana 或者 Cherry 至少一个</span></span><br><span class="line"><span class="comment">// (0101 &amp; 0010) || (0101 &amp; 0100) =&gt; 0000 || 0100 =&gt; true</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; FLAG_B) || (flags &amp; FLAG_C)) &#123;</span><br><span class="line">   <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mask = FLAG_B | FLAG_C; <span class="comment">// 0010 | 0100 =&gt; 0110</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; mask) &#123; <span class="comment">// 0101 &amp; 0110 =&gt; 0100 =&gt; true</span></span><br><span class="line">   <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过与掩码做或运算设置标志位，掩码中为 1 的位可以设置对应的位。例如掩码 1100 可用来设置位 C 和 D：（<strong>核心就是将某位变为1</strong> ）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们有 Cherry 和 Dew</span></span><br><span class="line"><span class="keyword">var</span> mask = FLAG_C | FLAG_D; <span class="comment">// 0100 | 1000 =&gt; 1100</span></span><br><span class="line">flags |= mask;   <span class="comment">// 0101 | 1100 =&gt; 1101</span></span><br></pre></td></tr></table></figure><p>可以通过与掩码做与运算清除标志位，掩码中为 0 的位可以设置对应的位。掩码可以通过对原语掩码做非运算得到。例如，掩码 1010 可以用来清除标志位 A 和 C ：（<strong>核心就是将某位变为0</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们没有 Apple 也没有 Cherry</span></span><br><span class="line"><span class="keyword">var</span> mask = ~(FLAG_A | FLAG_C); <span class="comment">// ~0101 =&gt; 1010</span></span><br><span class="line">flags &amp;= mask;   <span class="comment">// 1101 &amp; 1010 =&gt; 1000</span></span><br></pre></td></tr></table></figure><p>如上的掩码同样可以通过 ~FLAG_A &amp; ~FLAG_C 得到（德摩根定律）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们没有 Apple 也没有 Cherry</span></span><br><span class="line"><span class="keyword">var</span> mask = ~FLAG_A &amp; ~FLAG_C;</span><br><span class="line">flags &amp;= mask;   <span class="comment">// 1101 &amp; 1010 =&gt; 1000</span></span><br></pre></td></tr></table></figure><p>标志位可以使用异或运算切换。所有值为 1 的为可以切换对应的位。例如，掩码 0110 可以用来切换标志位 B 和 C：（<strong>核心就是将某位取反</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们以前没有 Banana ，那么我们现在有 Banana</span></span><br><span class="line"><span class="comment">// 但是如果我们已经有了一个，那么现在没有了</span></span><br><span class="line"><span class="comment">// 对 Cherry 也是相同的情况</span></span><br><span class="line"><span class="keyword">var</span> mask = FLAG_B | FLAG_C;</span><br><span class="line">flags = flags ^ mask;   <span class="comment">// 1100 ^ 0110 =&gt; 1010</span></span><br></pre></td></tr></table></figure><p>最后，所有标志位可以通过非运算翻转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entering parallel universe...</span></span><br><span class="line">flags = ~flags;    <span class="comment">// ~1010 =&gt; 0101</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;整理-【位运算经典应用】-标志位与掩码&quot;&gt;&lt;a href=&quot;#整理-【位运算经典应用】-标志位与掩码&quot; class=&quot;headerlink&quot; title=&quot;[整理]【位运算经典应用】 标志位与掩码&quot;&gt;&lt;/a&gt;[整理]【位运算经典应用】 标志位与掩码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文原文来源自 &lt;a href=&quot;http://www.cnblogs.com/zichi/p/4792589.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/zichi/p/4792589.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关内容经过整理, ABCD几个水果单词更加容易对应起来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们已经了解了六大位操作符（&lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;)的用法（&lt;a href=&quot;http://www.cnblogs.com/zichi/p/4787145.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;javascript 位运算&lt;/a&gt;），也整理了一些常用的位运算操作（&lt;a href=&quot;http://www.cnblogs.com/zichi/p/4789439.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常用位运算整理&lt;/a&gt;），本文我们继续深入位运算，来了解下二进制的经典应用-标志位与掩码。&lt;/p&gt;
&lt;p&gt;位运算经常被用来创建、处理以及读取标志位序列——一种类似二进制的变量。虽然可以使用变量代替标志位序列，但是这样可以节省内存（1/32）。&lt;/p&gt;
&lt;p&gt;例如有4个标志位：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标志位A： 我们有 Apple&lt;/li&gt;
&lt;li&gt;标志位B： 我们有 Banana&lt;/li&gt;
&lt;li&gt;标志位C： 我们有 Cherry&lt;/li&gt;
&lt;li&gt;标志位D： 我们有 Dew&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标志位通过位序列DCBA来表示，当一个位置被置为1时，表示有该项，置为0时，表示没有该项。例如一个变量flag=9，二进制表示为1001，就表示我们有D和A。&lt;/p&gt;
&lt;p&gt;掩码 (bitmask) 是一个通过与/或来读取标志位的位序列。典型的定义每个标志位的原语掩码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_A = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 0001&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_B = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 0010&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_C = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 0100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_D = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="mask" scheme="http://www.twosee.cn/tags/mask/"/>
    
  </entry>
  
</feed>
