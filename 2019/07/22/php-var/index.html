<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>PHP变量浅析 | TWO SEE | SEE is the sea of cc</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="php,zval">
    <meta name="description" content="这是一篇很久以前写的文章（大概是两年前），一直没发，可能囿于技术水平，有一些错误，已经草草修正了一些内容，如仍有写歪来的地方，欢迎拍砖。  我们每天都在和变量打交道，PHP的变量足够简单，当静态语言的初学者还在将类型推导（如C++写”auto foo &#x3D; 1”将自动推导foo为int类型）惊奇不已的时候，动态语言的开发者早已习以为常了。 但天下没有白吃的午餐，变量使用起来越方便，背后的原理就越复杂">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP变量浅析">
<meta property="og:url" content="http://www.twosee.cn/2019/07/22/php-var/index.html">
<meta property="og:site_name" content="TWO SEE">
<meta property="og:description" content="这是一篇很久以前写的文章（大概是两年前），一直没发，可能囿于技术水平，有一些错误，已经草草修正了一些内容，如仍有写歪来的地方，欢迎拍砖。  我们每天都在和变量打交道，PHP的变量足够简单，当静态语言的初学者还在将类型推导（如C++写”auto foo &#x3D; 1”将自动推导foo为int类型）惊奇不已的时候，动态语言的开发者早已习以为常了。 但天下没有白吃的午餐，变量使用起来越方便，背后的原理就越复杂">
<meta property="article:published_time" content="2019-07-22T03:11:42.000Z">
<meta property="article:modified_time" content="2021-05-17T10:07:55.878Z">
<meta property="article:author" content="Twosee">
<meta property="article:tag" content="php">
<meta property="article:tag" content="zval">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="TWO SEE" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://avatars2.githubusercontent.com/u/25978241?s=460&v=4">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Twosee</h5>
          <a href="mailto:twose@qq.com" title="twose@qq.com" class="mail">twose@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/twose" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/twoseee" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">PHP变量浅析</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">PHP变量浅析</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-07-22T03:11:42.000Z" itemprop="datePublished" class="page-time">
  2019-07-22
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#变量修饰符"><span class="post-toc-number">1.</span> <span class="post-toc-text">变量修饰符</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#PHP的栈和堆"><span class="post-toc-number"></span> <span class="post-toc-text">PHP的栈和堆</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#变量的存储方式"><span class="post-toc-number">1.</span> <span class="post-toc-text">变量的存储方式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP字符串变量的写时分离"><span class="post-toc-number">2.</span> <span class="post-toc-text">PHP字符串变量的写时分离</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP引用计数机制"><span class="post-toc-number">3.</span> <span class="post-toc-text">PHP引用计数机制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP数组变量的写时分离"><span class="post-toc-number">4.</span> <span class="post-toc-text">PHP数组变量的写时分离</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP数字变量的值拷贝"><span class="post-toc-number">5.</span> <span class="post-toc-text">PHP数字变量的值拷贝</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP无值布尔变量"><span class="post-toc-number">6.</span> <span class="post-toc-text">PHP无值布尔变量</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP的NULL"><span class="post-toc-number">7.</span> <span class="post-toc-text">PHP的NULL</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP变量引用"><span class="post-toc-number">8.</span> <span class="post-toc-text">PHP变量引用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP引用变量"><span class="post-toc-number">9.</span> <span class="post-toc-text">PHP引用变量</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP变量的循环引用"><span class="post-toc-number">10.</span> <span class="post-toc-text">PHP变量的循环引用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP变量的隐式转换、整数溢出"><span class="post-toc-number">11.</span> <span class="post-toc-text">PHP变量的隐式转换、整数溢出</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PHP变量的比较"><span class="post-toc-number">12.</span> <span class="post-toc-text">PHP变量的比较</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结语"><span class="post-toc-number">13.</span> <span class="post-toc-text">结语</span></a></li></ol>
        </nav>
    </aside>


<article id="post-php-var"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">PHP变量浅析</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-07-22 11:11:42" datetime="2019-07-22T03:11:42.000Z"  itemprop="datePublished">2019-07-22</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>这是一篇很久以前写的文章（大概是两年前），一直没发，可能囿于技术水平，有一些错误，已经草草修正了一些内容，如仍有写歪来的地方，欢迎拍砖。</p>
<hr>
<p>我们每天都在和变量打交道，PHP的变量足够简单，当静态语言的初学者还在将类型推导（如C++写”auto foo = 1”将自动推导foo为int类型）惊奇不已的时候，动态语言的开发者早已习以为常了。</p>
<p>但天下没有白吃的午餐，变量使用起来越方便，背后的原理就越复杂，你以为你已经能将变量运用自如，但其实你只是个会开车的普通司机，你并不懂车。而你若想要成为PHP世界的专业级赛车手，赛车的每个零部件到组装到核心引擎的运转，你都必须了如指掌。</p>
<a id="more"></a>
<h2 id="变量修饰符"><a href="#变量修饰符" class="headerlink" title="变量修饰符"></a>变量修饰符</h2><p>说到PHP变量，我们首先会想到那个令开发者们又爱又恨的<code>$</code>符。不管是喜欢它还是讨厌它的开发者，可能都不是很清楚为什么要用<code>$</code>来表示变量。</p>
<p>很多人都知道PHP很多的设计都受到了C的影响，毕竟PHP内核就是用C写的，就比如很多基础的函数名和C是一模一样的。但PHP还有一个很重要的前辈是Perl，开发者们普遍认为PHP用<code>$</code>符修饰变量是从Perl那里学来的，还有诸如”.”连接字符串，用”=&gt;”来设置数组(哈希)键值，”-&gt;”访问对象成员等。</p>
<p>早期的PHP还在写模板的时候，<code>$</code>也为程序员带来了很多好处，如直接在字符串内嵌入变量，甚至很多人并不知道它配合花括号还可以这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$o = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span><span class="params">(string $name)</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello &#123;$name&#125;!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&#123;$o-&gt;greet('PHP')&#125;"</span>;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello PHP!</span><br></pre></td></tr></table></figure>
<p>或是可变变量</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$foo = <span class="string">'bar'</span>;</span><br><span class="line">$$foo = <span class="string">'char'</span>;</span><br><span class="line">var_dump($bar);</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(4) &quot;char&quot;</span><br></pre></td></tr></table></figure><br>此外，<code>$</code>符修饰的变量永远不会和语言关键字冲突。</p>
<p>当然，这只能算是一些冷知识或是奇技淫巧，作为我们本篇的开胃菜。想要对PHP变量有新的认识，我们得先从表象入手，由浅入深，最后深入理解它的原理。</p>
<h1 id="PHP的栈和堆"><a href="#PHP的栈和堆" class="headerlink" title="PHP的栈和堆"></a>PHP的栈和堆</h1><p>为了搞清楚变量分配，我们还需要要了解PHP中的栈和堆，同样是内存，划分为栈和堆自然有分配上效率的原因。</p>
<p>我们事先准备好一块足够大的内存，这就是栈，程序运行时大量的变量符号所需的内存都在栈上挨个分配，函数调用时直接入栈出栈无需每次申请内存，这样就非常快。PHP甚至能事先计算好某个函数调用时需要多大的栈内存，内存不足时便会自动进行栈扩容。</p>
<p>我们运行时可能要创建一些字符串或者对象，它们可能会非常大，而且充满不确定性，这时候我们就需要向内存管理器动态地申请一块内存，有时候甚至可能会因为内存限制分配失败，这里所分配的内存就是堆区上的内存。</p>
<blockquote>
<p>TIP： PHP的栈区是在操作系统的堆区上，扩容时也可能会由于系统内存不足失败，但这很少发生，当系统内存不足时会直接把占用太多内存的进程强制kill掉。</p>
</blockquote>
<h2 id="变量的存储方式"><a href="#变量的存储方式" class="headerlink" title="变量的存储方式"></a>变量的存储方式</h2><p>首先我们要了解什么是动态语言，动态语言即是在“运行时”可以根据某些条件改变自身结构，如动态注册甚至替换函数等等；而静态语言一般在编译期就完成了函数定义、类型检查等事情。容易混淆的是，<strong>语言的强弱类型和动静态与否并没有关系</strong>，区别在于类型检查的时机：静态语言一般在编译期就进行了类型检查，而动态语言需要在运行时才能检查类型。</p>
<p>综上可知，PHP是一门典型的弱类型的动态语言，因为PHP中的变量，<strong>不仅是“量值”可变，“量的类型”也是可以随时变化的</strong>。PHP的变量无需声明，写即可用，非常方便，但这也造成了PHP内核无法在编译期间推断出所有变量的类型，如某个函数的运行结果依赖了外部数据，它的返回值可能是多种类型的，这样就无法在编译期有针对性地优化，而是在运行时不断地做检查。而PHP8想要实现JIT提升性能，就必须克服这个问题，所以PHP正不断地引入强类型特性，随着类型系统愈发完善，开发者也在有意识地<strong>减少动态类型的滥用</strong>，代码质量不断提高。</p>
<p>知道了这些以后，我们可以肯定地推测，PHP变量和其它静态语言变量的存储方式是不同的。如我们在C语言中声明一个字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span> = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>那么显而易见这个字符串占用了6个字节的内存（字符串长度 + \0终止符），这一点你可以用sizeof来验证。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%zu"</span>, <span class="keyword">sizeof</span>(<span class="string">"hello"</span>)); <span class="comment">// 输出6</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：PHP中的sizeof是count的别名，和占用内存并没有关系</p>
</blockquote>
<p>而由于PHP7增加了很多优化机制，我们并不能在PHP中直观地看见变量和内存的关系（这里指使用memory_get_usage函数，具体的原因我们将在后文讲到）。但我们可以通过分析PHP的内核，即Zend虚拟机的底层源码来推断。</p>
<p>如果你有一点C语言基础，那么你应该知道结构体、联合体和一些数据类型，我们可以来看看PHP变量在C底层的结构定义（因为是Zend引擎实现，所以被称作zval）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zval</span> &#123;</span></span><br><span class="line">  <span class="comment">/* 值 （8字节）*/</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    zend_long        lval; <span class="comment">// 对应int类型</span></span><br><span class="line">    <span class="keyword">double</span>           dval; <span class="comment">// 对应float类型</span></span><br><span class="line">    zend_string      *str; <span class="comment">// 对应string类型</span></span><br><span class="line">    zend_array       *arr; <span class="comment">// 对应array类型</span></span><br><span class="line">    zend_object      *obj; <span class="comment">// 对应object类型</span></span><br><span class="line">    zend_resource    *res; <span class="comment">// 对应resource类型</span></span><br><span class="line">    zend_reference   *ref; <span class="comment">// 对应引用类型</span></span><br><span class="line">  &#125; value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 类型信息 (4字节) */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    zend_uchar    type;    <span class="comment">// 存储了变量的类型，以找到对应的value</span></span><br><span class="line">    zend_uchar    type_flags; <span class="comment">// 内存管理使用，可忽略</span></span><br><span class="line">    <span class="keyword">uint16_t</span>      extra;</span><br><span class="line">  &#125; type_info;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 额外信息 (4字节，内存对齐冗余) */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>      extra;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是PHP的一个变量在底层的内存布局，这里过滤了一些暂时用不到的信息，简化了它的结构，看起来更加清晰，总的来说有三个部分：<strong>值、类型、额外信息</strong>，构成了PHP变量的容器”zval”。<br>我们先来计算一下它在64位机器上占用的内存大小：首先value是一个联合体，它的尺寸取决于它们中最大的那个，不管是long、double、还是指针类型，都正好是占用64位即8个字节；其次是类型信息结构体，一个无符号字符（char）1个字节，类型和类型标志加上额外冗余共计4个字节；最后还有一块额外冗余的值，也是4字节，一共加起来是<strong>16字节</strong>，这就是一个变量本身所占用的内存大小。</p>
<blockquote>
<p>不知道为什么有额外信息冗余的可以课外了解一下内存对齐的知识</p>
</blockquote>
<p>当一个变量是int或者float类型的时候，它占用的内存就正好是16字节，因为这个值是直接存在变量本身的内存中的，而变量的内存又是在PHP的栈区上；当一个变量是字符串、数组、对象、资源的时候，它的value存储的是一个指针，指针指向了真正变量值的内存地址，它是分配在堆区上的。</p>
<p>而我们所谈论的字符串，即zend_string的结构体又长这样，包含了三个固定属性：<strong>引用计数信息、哈希值、长度</strong>，在64位系统上一共是24个字节（refcount是4字节的，但是对齐到了8字节），而value的长度是根据字符串长度动态确定的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zend_string</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>          refcount; <span class="comment">// 引用计数，表示这个字符串被引用了几次</span></span><br><span class="line">  zend_ulong        hash;     <span class="comment">// 哈希缓存，在字符串对比时能够极大提高速度</span></span><br><span class="line">  <span class="keyword">size_t</span>            length;   <span class="comment">// 字符串长度，确保了字符串的二进制安全</span></span><br><span class="line">  <span class="keyword">char</span>              value[length];  <span class="comment">// 字符串内容，此处表示它的内存和这个结构体的内存是连续的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>已知PHP的字符串也是zero-termination（零结尾）的，那么我们可以推测出，一个字符串变量，就需要占用 “zval + zend_string + 字符串长度 + 1” 这么多的字节，以“hello”来计算就是46个字节（可能还需要内存对齐），而不是C语言中明明白白简简单单的6个字节。</p>
<h2 id="PHP字符串变量的写时分离"><a href="#PHP字符串变量的写时分离" class="headerlink" title="PHP字符串变量的写时分离"></a>PHP字符串变量的写时分离</h2><p>定义一个8字节的int类型，需要占用16字节的内存（PHP5时代甚至高达32字节，感谢PHP7的优化），定义一个长度为5的字符串，却要占用46个字节的内存，你可能不禁感到使用动态语言的内存代价十分昂贵。</p>
<p>事实确实如此，但也不尽然。</p>
<p>首先我们来看一个例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="string">'hello'</span>;</span><br><span class="line">$b = $a;</span><br></pre></td></tr></table></figure>
<p>我们都知道，PHP默认总是传值赋值，那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。被赋值的变量所持有的值，可以称作是副本。<br>那么把<code>$a</code>赋值给<code>$b</code>，是否就会产生一个<code>$a</code>的副本，一共占用两倍的内存呢？</p>
<p>其实不然，因为<strong>PHP采用了Copy-On-Write（写时复制）的机制，并使用引用计数管理内存</strong>。</p>
<p>已知zval上的zend_string是一个指针，那么其它zval也可以用指针指向这个字符串。让我们拆解着看：</p>
<p>当我们声明<code>$a</code>并赋值时：</p>
<ol>
<li>在栈上符号表中分配了一个<code>$a</code>的zval</li>
<li>在堆区申请内存，创建一个zend_string（24字节头部信息+5+1字节内容），拷贝”hello”给zend_string-&gt;value，设置length为5</li>
<li>赋值，设置<code>$a</code>的zval-&gt;value.str = 刚才创建zend_string</li>
</ol>
<p>当我们声明<code>$b</code>并将<code>$a</code>赋值给$b的时候，实则发生了以下事情:</p>
<ol>
<li>在栈上符号表中分配了一个<code>$b</code>的zval</li>
<li>拷贝了<code>$a</code>的zval给<code>$b</code>的zval，现在它们指向同一个zend_string</li>
<li>zend_string-&gt;refcount（引用计数）加1</li>
</ol>
<p>这时候我们知道了，字符串赋值并没有产生字符串的内存拷贝，只是拷贝了zval和增加了引用计数，两个变量都指向了同一个字符串。这样赋值的代价就非常小，几乎可以忽略不计。</p>
<p>如果我们修改了<code>$b</code>的字符串值呢？</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$b .= <span class="string">' world'</span>; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
<p>那么此时就会发生写时复制，也叫<strong>写时分离</strong>，即<code>$a</code>和<code>$b</code>不再指向同一个zend_string，这时候会创建一个真正的zend_string的副本给<code>$b</code>，而原来zend_string的引用计数减为1。<br>需要注意的是，如果字符串的内容非常大，那么哪怕只是对<code>$b</code>追加了一个字符，也将会占用双倍于原来以上内存，代价十分昂贵。</p>
<h2 id="PHP引用计数机制"><a href="#PHP引用计数机制" class="headerlink" title="PHP引用计数机制"></a>PHP引用计数机制</h2><p>刚才提到了引用计数这个东西，就不得不展开说一下，正如我们所见，zend_string的头部有一个refcount属性，表示这个zend_string被几个zval所引用了，当我们将它赋值给某个zval时，它就加1，当某个持有它的zval不再被用到时，它就减1，当它变为0的时候，表示再也没有zval指向它了，那么PHP内核就会根据zval的类型，调用相应的释放函数来释放它的内存。</p>
<p>PHP中常见的拥有引用计数的类型有：string、array、object，它们的数据结构的头部都是refcount。</p>
<p>其中，object大家都知道有构造、析构函数，当object的引用计数为0时，先会调用析构函数，再释放内存。</p>
<p>基于引用计数的内存管理方式好处显而易见：<strong>简单、可靠、实时回收、不会造成程序长时间停顿、还可以清晰地标明每一个变量的生命周期</strong>。但它也不是没有缺点，频繁且大量地更新计数也会有一定的开销，原始的引用计数也无法解决循环引用的问题。</p>
<h2 id="PHP数组变量的写时分离"><a href="#PHP数组变量的写时分离" class="headerlink" title="PHP数组变量的写时分离"></a>PHP数组变量的写时分离</h2><p>数组和字符串一样，都是在堆区分配内存，并由zval指向一个zend_array，zend_array的头部也有引用计数。</p>
<p>你可以暂且把数组简单看做一堆zval的集合，当数组发生写时分离时，只会拷贝数组本身，也就是产生一个新的zval的集合，所有数组上的有引用计数的zval，其计数都会加1，而不是数组上的每一个元素都会产生写时分离。</p>
<h2 id="PHP数字变量的值拷贝"><a href="#PHP数字变量的值拷贝" class="headerlink" title="PHP数字变量的值拷贝"></a>PHP数字变量的值拷贝</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = $a;</span><br></pre></td></tr></table></figure>
<p>这个例子里，<code>$a</code>和<code>$b</code>的zval.value.lval上都单独存储了一个8字节的0x00000001，而不是像字符串那样另有指向，因为zval只有16字节，且它总是在栈区上分配，无需单独申请一块内存，所以当我们赋值一个数字的时候，总是将整个zval拷贝过去，这样的拷贝非常快代价几乎可以忽略不计，并且省去了引用计数的管理。</p>
<h2 id="PHP无值布尔变量"><a href="#PHP无值布尔变量" class="headerlink" title="PHP无值布尔变量"></a>PHP无值布尔变量</h2><p>按照常人的理解，PHP的zval的布尔值设计一定是定义一个type为IS_BOOL，然后value中有一个zend_bool的值，为0时表示false，为1时表示true。</p>
<p>可事实上并不是这样，PHP使用type这一个量来实现布尔值，<strong>布尔型的zval对应了两种type：IS_TRUE和IS_FALSE</strong>。</p>
<p>这样在赋值一个变量为布尔值时，只需要改变zval的type，而不需要去修改zval的value。</p>
<h2 id="PHP的NULL"><a href="#PHP的NULL" class="headerlink" title="PHP的NULL"></a>PHP的NULL</h2><p>NULL和布尔值一样，只有type，没有value。这里又有一个常见的误区，即<strong>unset变量和设置一个变量为NULL是两种不一样的操作</strong>，unset是从符号表或数组中删除某个变量，而赋值null是将变量的type置为IS_NULL，更具体的区别，我们将在后续模块中讲到，这将涉及到一种隐藏类型的变量——UNDEF变量。</p>
<h2 id="PHP变量引用"><a href="#PHP变量引用" class="headerlink" title="PHP变量引用"></a>PHP变量引用</h2><p>我们已知zval只是一个变量的容器，它在管理字符串、数组、对象、资源的时候，都是采用指针指向的方式，而我们又常说，<strong>object（对象）总是传引用的</strong>，但这并不代表存储object的zval是一个引用变量。</p>
<p>结合我们上述分析，可以推出，对象在传递的时候，同样会拷贝zval，但是<strong>任我们如何操作对象，也永远不会发生写时分离产生新的对象</strong>，如此简单就实现了对象永远是”传引用”的机制了。</p>
<p>resource类型（资源）也是一样，略有不同的就是，资源都是向操作系统申请的，它无法被clone，即无法生成副本。</p>
<h2 id="PHP引用变量"><a href="#PHP引用变量" class="headerlink" title="PHP引用变量"></a>PHP引用变量</h2><p>引用变量是相对罕见的，它会引入一些复杂性，有时候难以拿捏。如<strong>最常见的错误就是将对象类型的变量进行引用赋值或引用传递</strong>，显而易见的多此一举。</p>
<p>引用变量和对象传引用不同，引用是符号表别名，它不是和object那样多个zval指向同一个对象的指针，而是引用变量的zval指向了被引用的zval，所有的修改都相当于对被引用的zval操作，唯一的例外是对引用变量使用unset，它不会删除被引用zval的值，而是解除了对其的引用。</p>
<p>由于写时拷贝的存在和PHP的一些优化措施，引用变量显得有些鸡肋，我们通常也不建议使用引用，让我们来看两个例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(string $a)</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a . <span class="string">'bar'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(string &amp;$a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $a .= <span class="string">'bar'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法会有什么性能差异吗？有一定C++基础的人或许不难看出，第二种写法在C++中的同等例子或许可以减少一次对象构造和内存拷贝，但在PHP中并不成立。</p>
<ol>
<li>当传入的<code>$a</code>引用计数为1时，在例一中，PHP会将字符串的改动直接作用于传入变量本身并返回，不会发生写时分离，效果和例二没有区别（这就是引用计数的优点之一，可以实时判断变量的生命周期状态，减少内存拷贝）。</li>
<li>当传入的<code>$a</code>引用计数大于1时，对于字符串的修改又引发了写时分离，例1和例2都会产生一个新的字符串副本。</li>
</ol>
<p>那么问题又来了，为什么PHP有些内置函数参数是引用的呢？比如非常常见的sort系列函数——那是因为这些函数的出现早于PHP4实现写时复制的版本，那时候的PHP还称不上严格意义上的语言。</p>
<p>所以在PHP中，<strong>随意滥用引用是不好的，不要期望引用能够提高性能，它多数时候只会惹是生非</strong>。</p>
<p>但引用肯定也有用武之地，那么什么时候我们才该使用引用呢？</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> &amp;$value) &#123;</span><br><span class="line">    $value += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> $index =&gt; $value) &#123;</span><br><span class="line">    $array[$index] += <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果你尝试拿一个大的<strong>关联数组</strong>做一下性能测试，就可以发现第一种的情况的运行速度优于第二种，为什么非得是关联数组呢？因为第二种方式每次增加键值时，都会多一次哈希查找的步骤。但如果不是关联数组，又有什么区别呢？这里有个新的知识点，我们留到后续数组的章节再来讨论。<br>此外，类似array_walk这样的数组遍历函数，当我们想修改数组内的值时，callback定义的参数通常也是加引用符的，若<strong>只是只读地访问变量，我们永远都不需要加引用</strong>。</p>
<h2 id="PHP变量的循环引用"><a href="#PHP变量的循环引用" class="headerlink" title="PHP变量的循环引用"></a>PHP变量的循环引用</h2><p>当我们已经初步了解了上述知识以后，我们就可以来思考这样一个问题，如果一个变量自己引用了自己，那么会发生什么？</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$foo = [];</span><br><span class="line">$foo[] = &amp;$foo;</span><br><span class="line">var_dump($foo);</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  &amp;<span class="keyword">array</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    [<span class="number">0</span>]=&gt;</span><br><span class="line">    *RECURSION*</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以由RECURSION看出来foo变量循环引用了自身，如果无限制递归地打印，将会变成死循环输出。<br>而当foo变量不再被用到时，它的引用计数减一，但由于它的内部自己引用了自己，它将永远保持最低为1的引用计数，将无法被释放。在PHP5.3以前，这种情况没有解决方案，只能依靠FPM模型下的重启VM解决，如果是常驻内存的应用，这种情况将会产生持续的内存泄漏。这也是前文提到的原始引用计数下无法解决的问题之一。</p>
<p>好在PHP5.3后引入了垃圾回收机制，通过一种同步回收算法，定量地深度度优先遍历疑似垃圾，进行模拟删除和模拟恢复，以此筛选得出循环引用的垃圾，然后进行内存回收，解决了这个问题。</p>
<p>但我们在开发中仍需重视循环引用的问题，降低垃圾回收的负担。</p>
<h2 id="PHP变量的隐式转换、整数溢出"><a href="#PHP变量的隐式转换、整数溢出" class="headerlink" title="PHP变量的隐式转换、整数溢出"></a>PHP变量的隐式转换、整数溢出</h2><p>前文我们已经说了PHP的变量是动态弱类型的，那么就意味着它允许变量之间的隐式转换。</p>
<p><strong>所谓隐式转换，就是指当你将A类型的变量当作B类型来操作时，A类型将会自动转换为B类型，而不是产生一个类型错误</strong>。</p>
<p>PHP底层定义了一系列convert方法来进行这样的转换，convert系列方法会先switch判断zval里存储的type，跳跃到对应的处理流程进行转换。</p>
<p>比较常见的隐式转换就是数字和字符串之间的转换，这里PHP巧妙地用“.”符号来表示字符串拼接，“+”符号来表示加法运算，在某些场景下很好地避免了错误的隐式转换类型。</p>
<p>此外，PHP的标量类型尽管在引入了函数类型定义的情况下，仍允许隐式转换，如当你将一个string类型的变量传给了一个限制了int类型的参数，string将会自动转为int，除非你在文件开头定义”declare(strict_types=1);”，这也是部分高质量开源库的硬性要求，这种做法在未来的PHP中将有很大受益。</p>
<p>类似PHP这样的动态类型语言还有一个通病就是不方便解决整数溢出问题，PHP的int型是有符号整数，比无符号的范围要小很多，大部分语言的解决方法就是在溢出时将数值转换成浮点型，PHP也是这么做的：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$foo = PHP_INT_MAX;</span><br><span class="line">var_dump($foo); <span class="comment">// 输出 int(9223372036854775807)</span></span><br><span class="line">$foo++;</span><br><span class="line">var_dump($foo); <span class="comment">// 输出 float(9.2233720368548E+18)</span></span><br><span class="line">$foo -= PHP_INT_MAX;</span><br><span class="line">var_dump($foo); <span class="comment">// 输出 float(0) 出现丢失</span></span><br></pre></td></tr></table></figure>
<p>但我们都知道，浮点型的精度有限，所以在某些时候，我们可能需要借助bcmath扩展来处理大数字。<br>此外值得一提的是，从数据库取大的整型数据这样的场景中，<strong>超出范围的整型变量PHP底层将会将其变成字符串型，以确保不会发生信息丢失。</strong></p>
<h2 id="PHP变量的比较"><a href="#PHP变量的比较" class="headerlink" title="PHP变量的比较"></a>PHP变量的比较</h2><p>作为一个有经验的PHP程序员，不可能不知道强等于（===）和弱等于（==）的区别。合格的PHPer大都首选强等于，加之PHP类型系统的不断完善，“declare(strict_types=1);”甚至也成了必选。</p>
<p>但很多开发者并没有注意到, PHP中还存在着使用松散比较的函数，如最常用的”in_array”，需要设定第三个参数为true，甚至最基础的switch语句使用的也是松散比较，稍不注意，就会陷入变量松散比较的陷阱中。</p>
<blockquote>
<p>以下返回结果都是true，你所忽视的变量松散比较正在破坏着你的程序逻辑<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump(in_array(<span class="string">'foo'</span>, [<span class="number">0</span>]));</span><br><span class="line">var_dump(in_array(<span class="number">0</span>, [<span class="string">'bar'</span>]));</span><br><span class="line">var_dump(in_array(<span class="keyword">null</span>, [[]]));</span><br></pre></td></tr></table></figure><br>这里还是涉及到了类型转换的知识，当两个不同类型的变量进行松散比较时，PHP内核总是按照特定规则将它们转为同一类型的变量，再进行比较。<br>但在PHP8中，某些不安全的比较行为可能会得到校正，如字符串总是等于0，这一改动会从语言的根本导致向下不兼容，但这是一个正确的方向，PHP8应该有这样的勇气去除糟粕，才能成大事。</p>
</blockquote>
<blockquote>
<p>相关RFC: <a href="https://wiki.php.net/rfc/string_to_number_comparison?fileGuid=mGhZJpuH2DsRCwY2" target="_blank" rel="noopener">https://wiki.php.net/rfc/string_to_number_comparison</a></p>
</blockquote>
<p>而强类型比较则是在弱比较的基础上，还判断了两个变量是否是相同类型的，因此它<strong>不会引发任何隐式的类型转换。</strong></p>
<p>除此之外，”==”的语义自然是”equal”，而“===”的语义实际上是”identical”，也就是“同一的“，对于PHP的一些基本类型，如数字、字符串、数组等，两个变量的值相等即可，但对于对象类型的比较，则要求是”同一个对象“，如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(<span class="keyword">new</span> stdClass === <span class="keyword">new</span> stdClass);</span><br></pre></td></tr></table></figure>
<p>这个例子中虽然两个对象别无二致，但由于不是同一个对象，将会返回false。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>PHP的变量说简单，是真的简单，无需声明，想用就用，或许很多开发者长久以来从未思考过变量背后的运作原理，只是一味地使用。实际上zva的设计十分精妙，用繁浩的底层代码来隐藏了编程的复杂性，让PHP开发者享受到了快乐开发的乐趣。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2021-05-17T10:07:55.878Z" itemprop="dateUpdated">2021-05-17 18:07:55</time>
</span><br>


        
        <a href="/2019/07/22/php-var/" target="_blank" rel="external">http://www.twosee.cn/2019/07/22/php-var/</a>
        
    </div>
    
    <footer>
        <a href="http://www.twosee.cn">
            <img src="https://avatars2.githubusercontent.com/u/25978241?s=460&v=4" alt="Twosee">
            Twosee
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zval/" rel="tag">zval</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.twosee.cn/2019/07/22/php-var/&title=《PHP变量浅析》 — TWO SEE&pic=https://avatars2.githubusercontent.com/u/25978241?s=460&v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.twosee.cn/2019/07/22/php-var/&title=《PHP变量浅析》 — TWO SEE&source=这是一篇很久以前写的文章（大概是两年前），一直没发，可能囿于技术水平，有一些错误，已经草草修正了一些内容，如仍有写歪来的地方，欢迎拍砖。

我们每天都在和..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.twosee.cn/2019/07/22/php-var/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《PHP变量浅析》 — TWO SEE&url=http://www.twosee.cn/2019/07/22/php-var/&via=http://www.twosee.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.twosee.cn/2019/07/22/php-var/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/04/17/swoole-fpm-proxy/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">使用Swoole协程一键代理PHP-FPM服务</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/06/28/my-college-life/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">9102记我刚刚结束的平平无奇的大学生活</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "BjOaCSsEoD25PlY0akiSOjLV-gzGzoHsz",
            appKey: "vz7DaO87fpAiBNIJAJmcqGm0",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Twosee &copy; 2003 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.twosee.cn/2019/07/22/php-var/&title=《PHP变量浅析》 — TWO SEE&pic=https://avatars2.githubusercontent.com/u/25978241?s=460&v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.twosee.cn/2019/07/22/php-var/&title=《PHP变量浅析》 — TWO SEE&source=这是一篇很久以前写的文章（大概是两年前），一直没发，可能囿于技术水平，有一些错误，已经草草修正了一些内容，如仍有写歪来的地方，欢迎拍砖。

我们每天都在和..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.twosee.cn/2019/07/22/php-var/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《PHP变量浅析》 — TWO SEE&url=http://www.twosee.cn/2019/07/22/php-var/&via=http://www.twosee.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.twosee.cn/2019/07/22/php-var/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABx0lEQVR42u3ay47CMAwF0P7/T3e2SNBybZMMSCcrFDrlZBZW/DiOeJ0P63n/6snHb692jhULFxd3zD1vV5X1/PwV+n7/6s24uLg7uVcRo/eTebDLDbi4uL/ITS4ueaDExcX9FW5ylckvTLi4uN/PzX/gnp4nUctzNVxc3AE3r1Ku+7ykvouLi9vinsU1SZCqge/F3+Li4m7hfvZq0guLyXtwcXF3cvMQMx+wyAsflzu4uLj/yo0KlzGxWv6IbmS4uLiLub3ixdlak+oHLi7uTm6ezOSDF73PhYIILi7uMm6SfuSJULVBUhi5wMXF3c7Nmx8TUJ4mRYEVFxd3Gbd3lcmTn2pX501YxMXF3cLNW57V4Yn5bNXlUXFxcbdzq2El30mOcfTuTbi4uAu4o5GIIHWZtE8KJRJcXNyPcnsjFJOjjmqhuLi427m91CU55OTGUq7Z4OLiDrifGqvqDW3k7dsXg1m4uLjLuJNrR4LOSyr5O3Fxcfdwqy2NvI1afWf0D8LFxd3I7Q1GVENbNWiWZ0ZwcXG/gJsEsmpb981RcXFxf4TbozRLqLi4uBu5K9Kb/JlCgxYXF3cLtxpKJsMZk7YuLi7uFu4fyNYBL991AfAAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
